\chapter{Scala AST}

This chapter describes the abstract syntax tree classes that are used in the Scala compiler. The implementations can be found in the \src{scala.reflect.generic.Trees} trait, ...

We start with the root class \src{Tree}, some of the more interesting traits and abstract classes and then describe all the concrete trees. Scala constructs -- syntactic sugar -- that are not represented as trees like parallel assignment and for-comprehensions are described in the last section.

Some remarks on the presentation: on the right of the tree class' name are its ancestor classes and traits. All concrete trees are case classes, so their parameters are listed below the class name.

\newcommand{\member} [2] {\hfill \begin{footnotesize}\src{#1} \newline \vspace{5pt} \src{#2}\end{footnotesize}\vspace{5pt}}

\section{Base Classes and Traits}

(A nice picture that shows the inheritance relations of the trees and traits)

\paragraph{Tree} \hfill \newline

\noindent The \src{Tree} class is the root of all other trees in the AST. It provides some common functionality for all other trees, for example the position (\src{\textit{pos}: Position}), the type (\src{\textit{tpe}: Type}), and the symbol (\src{\textit{symbol}: Symbol}). Not all subtrees have symbols or types, so these attributes might return \src{null}.

More operations of the \src{Tree} class are defined in \src{TreeOps}.

\paragraph{SymTree} \hfill \begin{footnotesize}\src{Tree}\end{footnotesize} \newline

\noindent The \src{SymTree} trait is extended by all trees that can have a symbol, but it returns \src{NoSymbol} by default.

\paragraph{DefTree} \hfill \begin{footnotesize}\src{SymTree <: Tree}\end{footnotesize} \newline

\noindent The \src{DefTree} class is extended by all trees that define or introduce a new entity into the program. Each \src{DefTree} also has a name and introduces a symbol.

\paragraph{RefTree} \hfill \begin{footnotesize}\src{SymTree <: Tree}\end{footnotesize} \newline

\noindent \src{RefTrees} are references to \src{DefTrees}. They also have a name and their symbol is the same as their corresponding \src{DefTree's}.

\paragraph{Symbol}

\paragraph{Position}

\paragraph{Name}

\section{Concrete Trees}

\paragraph{EmptyTree} \hfill \begin{footnotesize}\src{TermTree <: Tree}\end{footnotesize} \newline

\noindent An object that can stand in for most other trees, it has no position, no type and no symbol. For \src{ValDefs}, the equivalnt is the \src{emptyValDef} object.

\paragraph{PackageDef} \member{MemberDef <: DefTree <: SymTree <: Tree}{\textit{pid}: RefTree, \textit{stats}: List[Tree]}

\noindent Describes a package clause with a package identifier and a list of statements. The package identifier is either an instance of \src{Ident} for a package like \src{package a} or \src{Select} for a package name like \src{package a.b}. A compilation unit root is always a package, even if there is no explicit package declaration. In this case, the identifier is simply \src{<empty>}. According to the Scala Language Specification, the two different notations are equal:

\begin{multicols}{2}
\begin{lstlisting}
package a
package b.c
  
  
\end{lstlisting}

\begin{lstlisting}
package a {
  package b.c {
  }
}
\end{lstlisting}
\end{multicols}


If there exists a top level package definition, its position does not necessarily enclose the whole source file, everything that lies before the \src{package} keyword or after the last statement in the package is not contained in the position. In a package that contains no explicit package declaration and only one statement, the package definition has the same start and end position as the statement, but a different point.

\paragraph{ClassDef} \member{ImplDef <: MemberDef <: DefTree <: SymTree <: Tree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{tparams}: List[TypeDef], \textit{impl}: Template}

\noindent The definition for all kinds of classes and traits (objects are defined in \src{ModuleDef}). The definition contains all modifiers, the name and the type parameters. The class' constructor arguments, super classes and its body are all defined in the impl \src{Template}.

Modifiers are a set of \src{abstract, final, sealed, private, protected, trait, case}. The \src{class} keyword is not contained in the modifiers. If the class is anonymous (can be queried with \src{isAnonymousClass} on the class' symbol), the name is of the form \src{\$anon}.

\paragraph{ModuleDef} \member{ImplDef <: MemberDef <: DefTree <: SymTree <: Tree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{impl}: Template}

\noindent The definition of a singleton object, similar to the \src{ClassDef} except that a module does not take type parameters. 

\paragraph{Template} \member{SymTree <: Tree}{\textit{parents}: List[Tree], \textit{self}: ValDef, \textit{body}: List[Tree]}

\noindent The implementation of either a \src{ModuleDef} or \src{ClassDef}; also contains early definitions, super types, the self type annotation, and the statements in the class body. In the case of a \src{ClassDef}, it also contains the class' constructor parameters.

The following example illustrates into what constructor parameters and super constructor calls are desugared:

\begin{multicols}{2}
\begin{lstlisting}
class B(i: Int) extends A(i)





\end{lstlisting}

\begin{lstlisting}
class B extends A with ScalaObject {
  <paramaccessor> private[this] val i: Int = _
  def this(i: Int): B = {
    B.super.this(i)
  }
}
\end{lstlisting}
\end{multicols}

To identify the parameters from the list of body statements, we can check the modifiers of all \src{ValDefs} for the \src{PARAMACCESSOR} and \src{CASEACCESSOR} flags. In the same way, values and types from the early definition are identified by their \src{PRESUPER} flag. To check whether a value or type belongs to the early definitions, the compiler's \src{treeInfo.isEarlyDef} method can be used.

The super call parameters can be identified as follows: find the constructor \src{DefDef} (\src{symbol.isConstructor} is \src{true}) and then check its body \src{Block} for the following pattern: \src{Apply(Select(Super(\_, \_), \_), args)}. Because only super classes and not traits can have constructor arguments, there can be at most one such super call.

If the self type is not specified, it is the \src{emptyValDef} object. Otherwise, there are several different kinds of self type annotations:

\begin{multicols}{2}
\begin{lstlisting}
trait Trait {
}
trait ATrait {
  self =>
}
trait BTrait {
  self: ATrait =>
}
trait CTrait {
  self: BTrait with ATrait =>
}
\end{lstlisting}
\begin{lstlisting}
abstract trait Trait extends scala.AnyRef {
}
abstract trait ATrait extends scala.AnyRef { 
  self: ATrait => 
}
abstract trait BTrait extends scala.AnyRef {
  self: BTrait with ATrait =>
}
abstract trait CTrait extends scala.AnyRef {
  self: CTrait with BTrait with ATrait =>
}
\end{lstlisting}
\end{multicols}

We see that a self type annotation automatically intersects the current trait type with all explicitly named types. Extracting the exact positions of all type names is not trivial and involves searching the value's position for the occurences of the names.

It is also allowed to use \src{this} for the self type's name. This introduces no alias and the name of the \src{ValDef} is just \src{\_}.

\paragraph{ValDef} \member{ValOrDefDef <: MemberDef <: DefTree <: SymTree <: Tree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{tpt}: Tree, \textit{rhs}: Tree}

\noindent Value definitions are all definitions of \src{vals}, \src{vars} (identified by the \src{MUTABLE} flag) and parameters (identified by the \src{PARAM} flag).

The modifiers also contain the other properties a value can have: \src{override, abstract, final, implicit, lazy, private, protected}. Whether a modifier is applicable depends on the context where a value is used. A value can also be synthetic, i.e. compiler-generated (identified by the \src{SYNTHETIC} flag) -- for example in the following two equivalent statements, a synthetic value is passed to \src{println}:

\begin{lstlisting}
List(1, 2) foreach println
List(1, 2) foreach (println _)
\end{lstlisting}

Even though the value is compiler generated, it sometimes still has a name. In these examples, it is \src{x}, which is the name of \src{println}'s formal parameter. Sometimes, a name of the form \src{x\$1} is used.

Note that not every \src{val} in the source code is necessarily also represented by a \src{ValDef}. The following listing shows how the abstract value in the trait on the left is actually represented by the compiler:

\begin{multicols}{2}
\begin{lstlisting}
trait A {
  val a: Int
}
\end{lstlisting}
\begin{lstlisting}
abstract trait A extends scala.AnyRef {
  <stable> <accessor> def a: Int
}
\end{lstlisting}
\end{multicols}

In general, values are always private to the class. For external access, stable accessors are generated, as the following listing illustrates.

\begin{multicols}{2}
\begin{lstlisting}
class A {
  val a = 42

}
\end{lstlisting}
\begin{lstlisting}
class A extends Object with ScalaObject {
  private[this] val a: Int = 42;
  <stable> <accessor> def a: Int = A.this.a
}
\end{lstlisting}
\end{multicols}

Several methods defined on \src{Symbol} can be used to cross-reference between the getters, setters and their underlying value. The \src{accessed} method on a getter or setter symbol returns the underlying value's symbol. To get the corresponding setter or getter from a value, the methods \src{getter} and \src{setter} can be used.

\paragraph{DefDef} \member{ValOrDefDef <: MemberDef <: DefTree <: SymTree <: Tree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{tparams}: List[TypeDef], \textit{vparamss}: List[List[ValDef]], \textit{tpt}: Tree, \textit{rhs}: Tree}

\noindent The \src{DefDef} trees represent method definitions. Methods can have modifiers that further describe the implementation or constrain its visibility. Every method also has a name, but note that symbolic names are stored in their ASCII form, to get the original name, the symbol's \src{nameString} method can be used.

In contrast to a \src{ValDef}, a method can be parametrized with types and may have several argument lists. Each argument is represented by a \src{ValDef}.

Abstract methods have the \src{DEFERRED} flag and an \src{EmptyTree} right hand side child.

Finding methods in sub- or super classes requires the use of their \src{symbols}. Super classes can be found via the \src{ancestors} method on the class' symbol. In contrast, moving down the inheritance hierarchy is more expensive. To find all subclasses of a class $C$ one has to collect all other classes in the universe and test each's ancestors for the presence of $C$. Once the class hierarchy is assembled, the definition symbol's \src{overriddenSymbol} method can be used on each class in the hierarchy to gather all overrides.

\paragraph{TypeDef} \member{MemberDef <: DefTree <: SymTree <: Tree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{tparams}: List[TypeDef], \textit{rhs}: Tree}

\noindent \src{TypeDef} trees are definitions of types. The following listing shows three occurences -- \src{A, B, C} -- of \src{TypeDefs}:

\begin{lstlisting}
class Types {
  type A = Int
  type B >: Nothing <: AnyRef
  def d[C] ...
}
\end{lstlisting}

Just as the other member definitions trees (\src{ValDef} and \src{DefDef}), type definitions can have modifiers.

\paragraph{LabelDef} \member{DefTree <: SymTree  <: Tree $\wedge$ TermTree <: Tree}{name: Name, params: List[Ident], rhs: Tree}

\noindent %TODO

\paragraph{Import} \member{SymTree <: Tree}{\textit{expr}: Tree, \textit{selectors}: List[ImportSelector]}

\noindent An import statement imports one or many names -- the selectors -- from a package or object \src{expr}. An \src{ImportSelector} has two name-position pairs, the first one stands for the imported name and the second one is an optional renaming. Wildcard imports are also represented with an \src{ImportSelector}.

Import trees can also be comma separated, in this case, only the first import includes the \src{import} keyword in its position.

\paragraph{Block} \member{TermTree <: Tree}{\textit{stats}: List[Tree], \textit{expr}: Tree}

\noindent A \src{Block} encloses a list of statements in \src{\{ \ldots \}} and returns the value of its \src{expr} child. \src{Block} trees are only generated when needed -- for example, the right hand side of a \src{DefDef} with a single expression is not a \src{Block} but the expression itself, even when the expression is enclosed in \src{\{ \ldots \}}.

The \src{expr} is usually the last line of a block, with regards to their positions, but this is not always the case. For example, when creating an anonymous class, the class is introduced with a compiler generated name and then instantiated:

\begin{multicols}{2}
\begin{lstlisting}
val a = new {
}




\end{lstlisting}
\begin{lstlisting}
val a: java.lang.Object = {
  final class $anon extends scala.AnyRef {
    %\ldots%
  }
  new $anon()
}
\end{lstlisting}
\end{multicols}

\paragraph{CaseDef} \member{Tree}{\textit{pat}: Tree, \textit{guard}: Tree, \textit{body}: Tree}

\noindent The body of a \src{Match} tree contains a number of \src{CaseDefs} trees. The guard can be an empty tree if it is not present. Note that even though the \src{if} keyword is used, the tree is not an \src{If} tree.

Patterns can be of different form, the catch-all \src{\_} is simly an \src{Ident} tree, whereas extractors are represented through the \src{UnApply} trees. Patterns that use an \src{@} binding or are restricted by type with \src{:} are \src{Bind} trees. The body can again be an arbitrary tree.

\paragraph{Alternative} \member{TermTree <: Tree}{\textit{trees}: List[Tree]}

\noindent \src{Alternative} trees are used in case definitions to match on alternative clauses, they are separated by \src{|}.

\paragraph{Star} \member{TermTree <: Tree}{\textit{elem}: Tree}

\noindent Patterns can choose to match the whole remainder of an extracted sequence using the \src{\_*} pattern, as in the following example:

\begin{lstlisting}
"abcde".toList match {
  case Seq(car, cadr, _*) => car 
}
\end{lstlisting}

The wildcard-star is represented by the \src{Star} tree.

\paragraph{Bind} \member{DefTree <: SymTree <: Tree}{\textit{name}: Name, \textit{body}: Tree}

\noindent The \src{Bind} tree binds a name to an expression and is used in the patterns of \src{CaseDef}. We can see from some examples that several seemingly different syntax variations are all represented in a uniform way in the AST:

\begin{multicols}{2}
\begin{lstlisting}
list match {
  case i => %\ldots%
  case i: Int => %\ldots%
  case a @ i: Int => %\ldots%
}
\end{lstlisting}
\begin{lstlisting}
list match {
  case (i @ _) => %\ldots%
  case (i @ (_: Int)) => %\ldots%
  case (a @ (i @ (_: Int))) => %\ldots% 
}
\end{lstlisting}
\end{multicols}

\paragraph{UnApply} \member{TermTree <: Tree}{\textit{fun}: Tree, \textit{args}: List[Tree]}

\noindent When an extractor object is used in the pattern of a case definition, an \src{UnApply} tree is used. The arguments of \src{UnApply} can then be more  patterns.

\begin{multicols}{2}
\begin{lstlisting}
case Ex(i) => i

case a @ Ex(i) => i

case a @ Ex(i: Int) => i

\end{lstlisting}
\begin{lstlisting}
case Ex.unapply(<unapply-selector>) 
  <unapply> ((i @ _)) => i
case (a @ Ex.unapply(<unapply-selector>) 
  <unapply> ((i @ _))) => i
case (a @ Ex.unapply(<unapply-selector>) 
  <unapply> ((i @ (_: Int)))) => i
\end{lstlisting}
\end{multicols}

\paragraph{ArrayValue} \member{TermTree <: Tree}{\textit{elemtpt}: Tree, \textit{elems}: List[Tree]}

\paragraph{Function} \member{TermTree <: Tree $\wedge$ SymTree <: Tree}{vparams: List[ValDef], body: Tree}

\noindent The \src{Function} tree contains a single list of parameters and a body for the implementation. The following listing shows various usages of the \src{Function} tree and how their desugared function trees look like.

\begin{multicols}{2}
\begin{lstlisting}
list foreach println


list foreach (println _)


list foreach (i => println(i))
list foreach ((i: Int) => println(i))
list foreach {
  case i => println(i)
}
\end{lstlisting}
\begin{lstlisting}
list foreach ({
  ((x: Any) => println(x))
})
list foreach ({
  ((x: Any) => println(x))
})
list foreach (((i: Int) => println(i)))
list foreach (((i: Int) => println(i)))
list foreach (((x0$1: Int) => x0$1 match {
  case (i @ _) => println(i)
}))
\end{lstlisting}
\end{multicols}

In the first two examples, the functions are encapsulated in an additional \src{Block} (hence the curly braces). When the function parameter is not given a name explicitly, the compiler generates one and marks it with the \src{SYNTHETIC} flag. In the last of the examples, we can see that the pattern matching on the parameter is made explicit in the AST.

\paragraph{Assign} \member{TermTree <: Tree}{\textit{lhs}: Tree, \textit{rhs}: Tree}

\paragraph{If} \member{TermTree <: Tree}{\textit{cond}: Tree, \textit{thenp}: Tree, \textit{elsep}: Tree}

\noindent An \src{If} expression consists of three parts: the condition, the then part and the else part. If the else part is omitted, the literal \src{()} of type \src{Unit} is generated and the type of the conditional is set to an upper bound of \src{Unit} and the type of the then expression, usually \src{Any}.

\src{else if} terms are implemented using nested if conditionals. We can see this in the following listing.

\begin{multicols}{2}
\begin{lstlisting}
if (a)
  b
else if (c)
  d
else
  e

\end{lstlisting}
\begin{lstlisting}
if (a)
  b
else
  if (c)
    d
  else
    e
\end{lstlisting}
\end{multicols}

Note that the \src{if} used in pattern matching guards is not an \src{If} tree but a member of a \src{CaseDef} tree.

\paragraph{Match} \member{TermTree <: Tree}{\textit{selector}: Tree, \textit{cases}: List[CaseDef]}

\noindent A match tree is used to represent a pattern match, with the \src{selector} being the tree that is matched against. When a pattern matching expression is used as the body of a function, the selector is a synthetic value:

\begin{multicols}{2}
\begin{lstlisting}
list foreach {
  case i => println(i)
}
\end{lstlisting}
\begin{lstlisting}
list foreach (((x0$1: Int) => x0$1 match {
  case (i @ _) => println(i)
}))
\end{lstlisting}
\end{multicols}

\paragraph{Return} \member{TermTree <: Tree $\wedge$ SymTree <: Tree}{\textit{expr}: Tree}

\noindent The \src{Return} tree contains an expression that consitutes the return value. For \src{return} statements without an expression, the compiler generates a \src{()} literal.

\paragraph{Try} \member{TermTree <: Tree}{\textit{block}: Tree, \textit{catches}: List[CaseDef], \textit{finalizer}: Tree}

\paragraph{Throw} \member{TermTree <: Tree}{\textit{expr}: Tree}

\paragraph{New} \member{TermTree <: Tree}{\textit{tpt}: Tree}

\noindent The \src{New} tree represents \src{new} statements, the \src{tpt} member is the type that is being instantiated.

\paragraph{Typed} \member{TermTree <: Tree}{\textit{expr}: Tree, \textit{tpt}: Tree}

case i: Int

\paragraph{TypeApply} \member{GenericApply <: TermTree <: Tree}{\textit{fun}: Tree, \textit{args}: List[Tree]}

\paragraph{Apply} \member{GenericApply <: TermTree <: Tree}{\textit{fun}: Tree, \textit{args}: List[Tree]}

\paragraph{ApplyDynamic} \member{TermTree <: Tree $\wedge$ SymTree <: Tree}{\textit{qual}: Tree, \textit{args}: List[Tree]}

\paragraph{Super} \member{TermTree <: Tree $\wedge$ SymTree <: Tree}{\textit{qual}: Name, \textit{mix}: Name}

\noindent The \src{Super} tree represents a \src{super} call, with optional qualifier and super class specifier:

\begin{lstlisting}
trait A {
  def x = 42
}
trait B extends A {
  override def x = 43
}
class C extends A with B {
  println(super[A].x)
}
\end{lstlisting}

\paragraph{This} \member{TermTree <: Tree $\wedge$ SymTree <: Tree}{\textit{qual}: Name}

\noindent The \src{This} tree represents the \src{this} reference, with an optional qualifier:

\begin{lstlisting}
class Outer {
  class Inner {
    val outer = Outer.this
  }
}
\end{lstlisting}

\paragraph{Select} \member{RefTree <: Symtree <: Tree}{\textit{qualifier}: Tree, \textit{name}: Name}

\noindent The \src{Select} tree occurs on places that select a name from a qualifier, e.g. in method calls. Note that the typer fully qualifies references as illustrated in the following listing.

\begin{multicols}{2}
\begin{lstlisting}
class A {
  val a = %\ldots%
  val b = a
}
\end{lstlisting}
\begin{lstlisting}  
class A {
  val a = %\ldots%
  val b = A.this.a
}
\end{lstlisting}
\end{multicols}

As usual, these generated trees then have an \src{OffsetPosition}.

\paragraph{Ident} \member{RefTree <: Symtree <: Tree}{\textit{name}: Name}

\noindent Holds a \src{Name}, which can be generated (check with \src{symbol.isSynthetic}) by the compiler. Note that the name is in its ASCII form; the printed name can be found via the tree's symbol.

\paragraph{Literal} \member{TermTree <: Tree}{value: Constant}

\noindent All literals are represented by \src{Literal} trees. All possible kinds of constants can be seen in the \src{Constant} trait.

\paragraph{TypeTree} \member{AbsTypeTree <: TypTree <: Tree}{\textit{original}: Tree}

\noindent From the Scala compiler's documentation: 

\begin{quote}
A synthetic term holding an arbitrary type. Not to be confused with with TypTree, the trait for trees that are only used for type trees. TypeTrees are inserted in several places, but most notably in \src{RefCheck}, where the arbitrary type trees are all replaced by TypeTrees.\end{quote}

The original type tree is still accessible via the \src{TypeTree}'s \src{original} member. Note that the standard tree \src{Traverser} and \src{Transformer} visitors do not traverse into the \src{original} subtree.

\paragraph{SingletonTypeTree} \member{TypTree <: Tree}{\textit{ref}: Tree}

\paragraph{SelectFromTypeTree} \member{TypTree <: Tree $\wedge$ RefTree <: SymTree <: Tree}{\textit{qualifier}: Tree, \textit{name}: Name}

\paragraph{CompoundTypeTree} \member{TypTree <: Tree}{\textit{templ}: Template}

\paragraph{AppliedTypeTree} \member{TypTree <: Tree}{\textit{tpt}: Tree, \textit{args}: List[Tree]}

\paragraph{TypeBoundsTree} \member{TypTree <: Tree}{\textit{lo}: Tree, \textit{hi}: Tree}

\noindent Whenever a type is constrained to lower or upper bounds, \src{TypeBoundsTree} represents these bounds. If one of the bounds is omitted, the compiler inserts \src{Nothing} respectively \src{Any} for the missing lower or upper bound. This is illustrated in the following example.

\begin{multicols}{2}
\begin{lstlisting}
type B >: Nothing <: AnyRef
type C >: String
type D <: AnyRef
\end{lstlisting}
\begin{lstlisting}  
type B >: Nothing <: AnyRef
type C >: String <: Any
type D >: Nothing <: AnyRef
\end{lstlisting}
\end{multicols}


\paragraph{ExistentialTypeTree} \member{TypTree <: Tree}{\textit{tpt}: Tree, \textit{whereClauses}: List[Tree]}

\section{Others}

\paragraph{For Comprehensions}

\paragraph{Multiple Assignment}





