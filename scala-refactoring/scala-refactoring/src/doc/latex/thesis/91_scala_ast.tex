\chapter{Scala Internals}

This chapter will describe the individual tree classes that are used in the Scala compiler. It starts with the root class \src{Tree} and then describes all trees in an alphabetic order.

\newcommand{\member} [2] {\hfill \begin{footnotesize}\src{#1} \newline \vspace{5pt} \src{#2}\end{footnotesize}\vspace{5pt}}

\section{Base Classes and Traits}


\paragraph{Tree}

\paragraph{MemberDef}

...

\section{Concrete Trees}

\paragraph{EmptyTree} \member{TermTree}{}

\noindent An object that can stand in for most other trees, it has no position, no type and no symbol.

\paragraph{PackageDef} \member{MemberDef <: DefTree <: SymTree}{\textit{pid}: RefTree, \textit{stats}: List[Tree]}

\noindent Describes a package clause with a package identifier and a list of statements. The package identifier is either an instance of \src{Ident} for a package like \src{package a} or \src{Select} for a package name like \src{package a.b}. A compilation unit root is always a package, even if there is no explicit package declaration. In this case, the identifier is simply \src{<empty>}. According to the Scala Language Specification, the two different notations are equal:

\begin{multicols}{2}
\begin{lstlisting}
package a
package b.c
  
  
\end{lstlisting}

\begin{lstlisting}
package a {
  package b.c {
  }
}
\end{lstlisting}
\end{multicols}


If there exists a top level package definition, its position does not necessarily enclose the whole source file, everything that lies before the \src{package} keyword or after the last statement in the package is not contained in the position. In a package that contains no explicit package declaration and only one statement, the package definition has the same start and end position as the statement, but a different point.

\paragraph{ClassDef} \member{ImplDef <: MemberDef <: DefTree <: SymTree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{tparams}: List[TypeDef], \textit{impl}: Template}

\noindent The definition for all kinds of classes and traits (objects are defined in \src{ModuleDef}). The definition contains all modifiers, the name and the type parameters. The class' constructor arguments, super classes and its body are all defined in the impl \src{Template}.

Modifiers are a set of \src{override, abstract, final, sealed, private, protected, trait, case}. The \src{class} keyword is not contained in the modifiers. If the class is anonymous (can be queried with \src{isAnonymousClass} on the class' symbol), the name is of the form \src{\$anon}.

\paragraph{ModuleDef} \member{ImplDef <: MemberDef <: DefTree <: SymTree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{impl}: Template}

\noindent The definition of a singleton object, similar to the \src{ClassDef} except that a module does not take type parameters.

\paragraph{Template} \member{SymTree}{\textit{parents}: List[Tree], \textit{self}: ValDef, \textit{body}: List[Tree]}

\noindent The implementation of either a \src{ModuleDef} or \src{ClassDef}; also contains early definitions, super types, the self type annotation, and the statements in the class body. In the case of a \src{ClassDef}, it also contains the class's constructor parameters.

The following example illustrates into what constructor parameters and super constructor calls are desugared:

\begin{multicols}{2}
\begin{lstlisting}
class B(i: Int) extends A(i)





\end{lstlisting}

\begin{lstlisting}
class B extends A with ScalaObject {
  <paramaccessor> private[this] val i: Int = _
  def this(i: Int): B = {
    B.super.this(i)
  }
}
\end{lstlisting}
\end{multicols}

To identify the parameters from the list of body statements, we can check the modifiers of all \src{ValDefs} for the \src{PARAMACCESSOR} and \src{CASEACCESSOR} flags. In the same way, values and types from the early definition are identified by their \src{PRESUPER} flag. To check whether a value or type belongs to the early definitions, the compiler's \src{treeInfo.isEarlyDef} method can be used.

The super call parameters can be identified as follows: find the constructor \src{DefDef} (\src{symbol.isConstructor} is \src{true}) and then check its body \src{Block} for the following pattern: \src{Apply(Select(Super(\_, \_), \_), args)}. Because only super classes and not traits can have constructor arguments, there can be at most one such super call.

If the self type is not specified, it is the \src{emptyValDef} object. Otherwise, there are several different kinds of self type annotations:

\begin{multicols}{2}
\begin{lstlisting}
trait Trait {
}
trait ATrait {
  self =>
}
trait BTrait {
  self: ATrait =>
}
trait CTrait {
  self: BTrait with ATrait =>
}
\end{lstlisting}
\begin{lstlisting}
abstract trait Trait extends scala.AnyRef {
}
abstract trait ATrait extends scala.AnyRef { 
  self: ATrait => 
}
abstract trait BTrait extends scala.AnyRef {
  self: BTrait with ATrait =>
}
abstract trait CTrait extends scala.AnyRef {
  self: CTrait with BTrait with ATrait =>
}
\end{lstlisting}
\end{multicols}

We see that a self type annotation automatically intersects the current trait type with all explicitly named types. Extracting the exact positions of all type names is not trivial and involves searching the value's position for the occurences of the names.

It is also allowed to use \src{this} for the self type's name. This introduces no alias and the name of the \src{ValDef} is just \src{\_}.

\paragraph{ValDef} \member{ValOrDefDef <: MemberDef <: DefTree <: SymTree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{tpt}: Tree, \textit{rhs}: Tree}

\noindent Value definitions are all definitions of \src{vals}, \src{vars} (identified by the \src{MUTABLE} flag) and parameters (identified by the \src{PARAM} flag).

The modifiers also contain the other properties a value can have: \src{override, abstract, final, implicit, lazy, private, protected}. Whether a modifier is applicable depends on the context where a value is used. A value can also be synthetic, i.e. compiler-generated (identified by the \src{SYNTHETIC} flag) -- for example in the following two equivalent statements, a synthetic value is passed to \src{println}:

\begin{lstlisting}
List(1, 2) foreach println
List(1, 2) foreach (println _)
\end{lstlisting}

Even though the value is compiler generated, it sometimes still has a name. In these examples, it is \src{x}, which is the name of \src{println}'s formal parameter. Sometimes, a name of the form \src{x\$1} is used.

Note that not every \src{val} in the source code is necessarily also represented by a \src{ValDef}. The following listing shows how the abstract value in the trait on the left is actually represented by the compiler:

\begin{multicols}{2}
\begin{lstlisting}
trait A {
  val a: Int
}
\end{lstlisting}
\begin{lstlisting}
abstract trait A extends scala.AnyRef {
  <stable> <accessor> def a: Int
}
\end{lstlisting}
\end{multicols}

In general, values are always private to the class. For external access, stable accessors are generated, as the following listing illustrates.

\begin{multicols}{2}
\begin{lstlisting}
class A {
  val a = 42

}
\end{lstlisting}
\begin{lstlisting}
class A extends Object with ScalaObject {
  private[this] val a: Int = 42;
  <stable> <accessor> def a: Int = A.this.a
}
\end{lstlisting}
\end{multicols}

Several methods defined on \src{Symbol} can be used to cross-reference between the getters, setters and their underlying value. The \src{accessed} method on a getter or setter symbol returns the underlying value's symbol. To get the corresponding setter or getter from a value, the methods \src{getter} and \src{setter} can be used.

Multiple assignment is also


\paragraph{DefDef} \member{ValOrDefDef <: MemberDef <: DefTree <: SymTree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{tparams}: List[TypeDef], \textit{vparamss}: List[List[ValDef]], \textit{tpt}: Tree, \textit{rhs}: Tree}

\noindent The \src{DefDef} trees represent method definitions. Methods can have modifiers that further describe the implementation or constrain its visibility. Every method also has a name, but note that symbolic names are stored in their ASCII form, to get the original name, the symbol's \src{nameString} method can be used.

In contrast to a \src{ValDef}, a method can be parametrized with types and may have several argument lists. Each argument is represented by a \src{ValDef}.

Abstract methods have the \src{DEFERRED} flag and an \src{EmptyTree} right hand side child.

Finding methods in sub- or super classes requires the use of their \src{Symbols}. Super classes can be found via the \src{ancestors} method on the class' symbol. Going into the other direction of the inheritance hierarchy is more expensive, one has to collect all classes and test each class' ancestors. Once the class hierarchy is assembled, the definition symbol's \src{overriddenSymbol} can be used on each class in the hierarchy to gather all overrides.

\paragraph{TypeDef} \member{MemberDef <: DefTree <: SymTree}{\textit{mods}: Modifiers, \textit{name}: Name, \textit{tparams}: List[TypeDef], \textit{rhs}: Tree}

\noindent \src{TypeDef} trees are definitions of types. The following listing shows three occurences -- \src{A, B, C} -- of \src{TypeDefs}:

\begin{lstlisting}
class Types {
  type A = Int
  type B >: Nothing <: AnyRef
  def d[C] ...
}
\end{lstlisting}

Just as the other member definitions trees (\src{ValDef} and \src{DefDef}), type definitions can have modifiers.

\paragraph{LabelDef} \member{DefTree <: SymTree $\wedge$ TermTree}{name: Name, params: List[Ident], rhs: Tree}

\noindent %TODO

\paragraph{Import} \member{SymTree}{\textit{expr}: Tree, \textit{selectors}: List[ImportSelector]}

\noindent An import statement imports one or many names -- the selectors -- from a package or object \src{expr}. An \src{ImportSelector} has two name-position pairs, the first one stands for the imported name and the second one is an optional renaming. Wildcard imports are also represented with an \src{ImportSelector}.

Import trees can also be comma separated, in this case, only the first import includes the \src{import} keyword in its position.

\paragraph{Block} \member{TermTree}{\textit{stats}: List[Tree], \textit{expr}: Tree}

\noindent A \src{Block} encloses a list of statements in \src{\{ \ldots \}} and returns the value of its \src{expr} child. \src{Block} trees are only generated when neede, e.g. the right hand side of a \src{DefDef} with a single expression is not a \src{Block} but the expression itself, even when the expression is enclosed in \src{\{ \ldots \}}.

The \src{expr} is usually the last line of a block, with regards to their positions, but this is not always the case. For example, when creating an anonymous class, the class is introduced with a compiler generated name and then instantiated:

\needspace{6\baselineskip}
\begin{multicols}{2}
\begin{lstlisting}
val a = new {
}




\end{lstlisting}
\begin{lstlisting}
val a: java.lang.Object = {
  final class $anon extends scala.AnyRef {
    %\ldots%
  }
  new $anon()
}
\end{lstlisting}
\end{multicols}



\paragraph{CaseDef} \member{Tree}{\textit{pat}: Tree, \textit{guard}: Tree, \textit{body}: Tree}

\paragraph{Alternative} \member{TermTree}{\textit{trees}: List[Tree]}

\paragraph{Star} \member{TermTree}{\textit{elem}: Tree}

\paragraph{Bind} \member{DefTree <: SymTree}{\textit{name}: Name, \textit{body}: Tree}

\paragraph{UnApply} \member{TermTree}{\textit{fun}: Tree, \textit{args}: List[Tree]}

\paragraph{ArrayValue} \member{TermTree}{\textit{elemtpt}: Tree, \textit{elems}: List[Tree]}

\paragraph{Function} \member{TermTree $\wedge$ SymTree}{vparams: List[ValDef], body: Tree}

\paragraph{Assign} \member{TermTree}{\textit{lhs}: Tree, \textit{rhs}: Tree}

\paragraph{If} \member{TermTree}{\textit{cond}: Tree, \textit{thenp}: Tree, \textit{elsep}: Tree}

\noindent An \src{If} expression consists of three parts: the condition, the then part and the else part.

result type?

\src{else if} terms are implemented using nested if conditionals.

\paragraph{Match} \member{TermTree}{\textit{selector}: Tree, \textit{cases}: List[CaseDef]}

\paragraph{Return} \member{TermTree $\wedge$ SymTree}{\textit{expr}: Tree}

\paragraph{Try} \member{TermTree}{\textit{block}: Tree, \textit{catches}: List[CaseDef], \textit{finalizer}: Tree}

\paragraph{Throw} \member{TermTree}{\textit{expr}: Tree}

\paragraph{New} \member{TermTree}{\textit{tpt}: Tree}

\paragraph{Typed} \member{TermTree}{\textit{expr}: Tree, \textit{tpt}: Tree}

\paragraph{TypeApply} \member{GenericApply <: TermTree}{\textit{fun}: Tree, \textit{args}: List[Tree]}

\paragraph{Apply} \member{GenericApply <: TermTree}{\textit{fun}: Tree, \textit{args}: List[Tree]}

\paragraph{ApplyDynamic} \member{TermTree $\wedge$ SymTree}{\textit{qual}: Tree, \textit{args}: List[Tree]}

\paragraph{Super} \member{TermTree $\wedge$ SymTree}{\textit{qual}: Name, \textit{mix}: Name}

\paragraph{This} \member{TermTree $\wedge$ SymTree}{\textit{qual}: Name}

\paragraph{Select} \member{RefTree}{\textit{qualifier}: Tree, \textit{name}: Name}

\paragraph{Ident} \member{RefTree}{\textit{name}: Name}

\paragraph{Literal} \member{TermTree}{value: Constant}

\paragraph{SingletonTypeTree} \member{TypTree}{\textit{ref}: Tree}

\paragraph{SelectFromTypeTree} \member{TypTree $\wedge$ RefTree}{\textit{qualifier}: Tree, \textit{name}: Name}

\paragraph{CompoundTypeTree} \member{TypTree}{\textit{templ}: Template}

\paragraph{AppliedTypeTree} \member{TypTree}{\textit{tpt}: Tree, \textit{args}: List[Tree]}

\paragraph{TypeBoundsTree} \member{TypTree}{\textit{lo}: Tree, \textit{hi}: Tree}

\paragraph{ExistentialTypeTree} \member{\textit{tpt}: Tree, \textit{whereClauses}: List[Tree]}




only AST and symbols, but with more detail, refer to the term project for the compiler organization and introduction.

first the general cases and then more complex and surprising examples

also build stand-alone and publish on the project page.
