\documentclass[10pt,a4paper,oneside]{scrreprt}
\usepackage{mystyle}

\begin{document}

\newcommand{\subtitlename}{Master's Thesis}
\newcommand{\titlename}{Refactoring for Scala}

\include{0_front}

\chapter*{Abstract}

\pagenumbering{roman}

This thesis..


\chapter*{Management Summary}

This documentation 

\newpage

\setcounter{tocdepth}{2}

\tableofcontents

\newpage

\pagenumbering{arabic}

\chapter{Introduction}
\section{Problem Outline}
\section{Thesis Goals}

\chapter{Refactoring Library}

describes the three main modules of the refactoring library.

\section{Overview}

an introduction, mention the basic concepts, also say that trees have to keep their positions if the source code should be regenerated.

\section{Analysis}

explain the symbol index to resolve symbols to trees

\section{Transformation}

At the heart of every refactoring lies a \textit{transformation} that takes the current program in its abstract syntax tree form and transforms it into its refactored form. Such a transformation can be as simple as changing names -- think of the Rename refactoring -- or restructure large parts of the AST as in an Extract or Move refactoring. 

Often, a larger refactoring comprises many smaller transformations. An illustrative example is the Extract Method refactoring, which can be assembled from three basic transformations:

\begin{description}
 \item[Create Method] to introduce a new (empty) method.
 \item[Copy Statements] to copy the selected statements into the newly created method.
 \item[Replace Statements] to replace the original statements that have been copied to the new method with a call to it.
\end{description}

The \textit{replace} transformation itself is again a combination of two even more fundamental transformations: \textit{insert} and \textit{delete}. Once we have our Extract Method transformation, it can then again be combined with other transformations -- for example into an Extract Class refactoring. It should be clear from this that the key to a reusable refactoring library lies in the composability of its transformations. 

Conceptually, chaining simple transformations to build more powerful ones follows the Unix pipes philosophy. The design of this implementation was inspired by the Stratego program transformation tool-set (referenz) and the Kiama language processing library (referenz). Functional programming also uses the term \textit{combinator} to denote functions that can be combined and yield new functions of the same kind. An example of this are parser combinators (referenz), which are part of the Scala standard library.

In contrast to unix pipes that operate on their input line by line, performing transformations on a tree datastructure adds an additional dimension. When transforming trees, we are also concerned with questions on how we want to traverse the tree -- i.e. pre-order or post-order -- and to which children a transformation should be applied. The presented implementation handles all these concerns in a uniform way.

In the remainder of this section, we will develop the basics of our transformation combinators and show examples of their usage.

\subsection{Transformations}

A refactoring transformation is essentially a function that transforms a tree into an other tree. But because most transformations do not apply to all kinds of possible trees, we model a transformation as a function of type $Tree\Rightarrow Option[Tree]$, making use of Scala's \src{Option} monad to indicate inability to transform. In the actual implementation, the transformations are implemented generically as a \src{Transformation[A,~B]} that extend \src{A~$\Rightarrow$~Option[B]}:

\begin{lstlisting}
abstract class Transformation[A, B] extends (A %$\Rightarrow$% Option[B]) {
  self %$\Rightarrow$%

  def apply(in: A): Option[B]
%\ldots%
}
\end{lstlisting}

The explicit self type annotation\footnote{In this case, think of the self type annotation as an alias for \src{this} that can be used in the body of the class.} will be used later in the implementation of the combinators. Note that all transformations are implemented polymorphic, but to make the explanations more clear, we will assume that they are used to transform trees.

Transformations can be created from partial functions using the \src{transformation} convenience function. As an example, we create a transformation that reverses the order of a class, trait, or object's member definitions and apply it to a given template instance.

\begin{lstlisting}
def transformation[A, B](f: PartialFunction[A, B]) = new Transformation[A, B] {
  def apply(t: A): Option[B] = f lift t
}

val reverseTemplateMembers = transformation[Tree, Tree] {
  case t: Template %$\Rightarrow$% t copy (body = t.body.reverse)
}

val result: Option[Tree] = reverseTemplateMembers(template)
\end{lstlisting}

Now that we have a way to create single transformations, we need to be able to combine them. To do this in various ways, we introduce several combinators. We use a notational shortcut to denote transformations: $A \overset{t}{_\rightarrow} [B]$ is a \src{Transformation [A, B]}.

There also exist two basic transformations, one that always succeeds, returning its input unchanged, and one that always fails, independent of its input. Depending on the context, the alias \src{id} for \src{succeed} might be a better fit and is provided as well.

\begin{lstlisting}
def succeed[A] = new Transformation[A, A] {
  def apply(a: A): Option[A] = Some(a)
}

def id[A] = success[A]

def fail[A] = new Transformation[A, A] {
  def apply(a: A): Option[A] = None
}
\end{lstlisting}

\subsection{Combinators}

There are several existing combinators already implemented in the library. On the right side of each paragraph, the symbolic or alphanumeric name and type of the transformation is shown.

\paragraph{Sequence} \hfill \lstinline{&>: } $(A \overset{t}{\rightarrow} [B]) \Rightarrow (B \overset{t}{\rightarrow} [C]) \Rightarrow (A \overset{t}{\rightarrow} [C])$

\vspace{7pt} Combines two transformations so that the second one is only applied when the first one succeeded. The result of the first transformation is passed into the second one. This is implemented as the \src{andThen} method -- or alternatively with the \src{\&>} operator -- on \src{Transformation}, which takes the second transformation as a by-name parameter:

\begin{lstlisting}
abstract class Transformation[A, B] extends (A %$\Rightarrow$% Option[B]) {
  self %$\Rightarrow$%

  def apply(in: A): Option[B]

  def andThen[C](t: %$\Rightarrow$% Transformation[B, C]) = new Transformation[A, C] {
    def apply(a: A): Option[C] = {
      self(a) flatMap t
    }
  }
  def &>[C](t: %$\Rightarrow$% Transformation[B, C]) = andThen(t)
%\ldots%
\end{lstlisting}


\paragraph{Alternative} \hfill \lstinline{|>: } $(A \overset{t}{\rightarrow} [B]) \Rightarrow (A \overset{t}{\rightarrow} [B]) \Rightarrow (A \overset{t}{\rightarrow} [B])$

\vspace{7pt} Combines two transformations so that the second one is only applied in case the first one fails. The implementation is directly based on the underlying \src{Option} type in the \src{orElse} method on \src{Transformation} and also has an operator alias:

\begin{lstlisting}
abstract class Transformation[A, B] extends (A %$\Rightarrow$% Option[B]) {
  self %$\Rightarrow$%

  def apply(in: A): Option[B]

  def orElse(t: %$\Rightarrow$% Transformation[A, B]) = new Transformation[A, B] {
    def apply(a: A): Option[B] = {
      self(a) orElse t(a)
    }
  }
  def |>(t: %$\Rightarrow$% Transformation[A, B]) = orElse(t)
%\ldots%
\end{lstlisting}

With these two combinators, we are already able to represent conditional transformations. For example, given a transformation \src{isClass} that acts as a predicate, and two transformations \src{a} and \src{b} that represent the two possible branches the transformation can take, we can combine them into a new transformation \src{isClass \&> a |> b} that executes the \src{a} transformation if the \src{isClass} transformation succeeds or \src{b} if either \src{isClass} or \src{a} fails.

Note that due to Scala's precedence rules, the \src{|>} combinator has a lower precedence than \src{\&>}.

\paragraph{Predicate} \hfill \lstinline{predicate: } $(A \overset{?}{\rightarrow} Boolean) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} As we have seen, transformations can be used as predicates. We often want to construct a predicate from a function that returns a boolean value. This can be done with the \src{predicate} function which create a transformation from a partial function.

\begin{lstlisting}
def predicate[A](f: %$\Rightarrow$% PartialFunction[A, Boolean]) = new Transformation[A, A] {
  def apply(a: A): Option[A] = if (f.isDefinedAt(a) && f(a)) Some(a) else None
}
\end{lstlisting}

\paragraph{Not} \hfill \lstinline{!: } $(A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} A combinator that inverts a transformation. Given a transformation that succeeds, then \src{not} will fail. Should the given transformation fail, then \src{not} returns the original input unchanged. This behavior is useful for transformations that act as predicates; \src{not} can be implemented using the \src{fail} and \src{id} transformations as follows.

\begin{lstlisting}
def not[A](t: %$\Rightarrow$% Transformation[A, A]) = t &> fail |> succeed
\end{lstlisting}

Now that we have several means to specify and combine our transformations, we also need a way to apply them to a whole AST, instead of just single tree nodes. For this, there exist several traversal strategies.

\subsection{Traversal}

Applying a transformation to a single tree element is not difficult, but once we want to traverse the whole AST, we need a way to apply a transformation to all children of a tree node and to construct a new tree from the result of the transformation operation. Note that traversal strategies are also just transformations that can again be combined.

\paragraph{All Children} \hfill  $allChildren: (A \overset{t}{\rightarrow} [B]) \Rightarrow (A \overset{t}{\rightarrow} [B])$

\vspace{7pt} Takes a transformation and creates a new one that applies the given transformation to all children, returning a single tree. Because there is no generic way to get all children and construct a new tree, we constrain the type parameter \src{A} to be convertible to $(A \Rightarrow B) \Rightarrow B$. This means that the user of the generic transformation has to pass us its children and create a new tree. When a child cannot be transformed, \src{allChildren} immediately aborts and returns \src{None}.

\begin{lstlisting}
def allChildren[A <%\%% (A %$\Rightarrow$% B) %$\Rightarrow$% B, B](t: %$\Rightarrow$% Transformation[A, B]) = new Transformation[A, B] {
  def apply(a: A): Option[B] = {
    Some(a(child %$\Rightarrow$% t(child) getOrElse (return None)))
  }
}
\end{lstlisting}

(\src{X <\% Y} is called a \textit{view bound} and demands that there exists an implicit conversion from type \src{X} to \src{Y}. This is less constrictive than \src{X <: Y}, where \src{X} has to be a subtype of \src{Y}. In our case, we can then treat \src{a} as if it were of type \src{(A $\Rightarrow$ B) $\Rightarrow$ B}. This allows us to apply the transformation to the children of \src{a}.)

\paragraph{Matching Children} \hfill $matchingChildren: (A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} The \src{allChildren} traversal only succeeds when the transformation can be applied to all children. If children that cannot be transformed should simply be kept and passed to the new tree unchanged, we can use the \src{matchingChildren} transformation.

\begin{lstlisting}
def matchingChildren[A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = allChildren(t |> id[A])
\end{lstlisting}

Using the \src{id} transformation, we retain the original tree should the transformation not be applicable. A consequence of this is that the transformation needs to be done between the same types.

%\paragraph{Once} \hfill \lstinline{once: } $(A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

%\vspace{7pt} Applies a transformation and stops on the first successful application... not yet implemented.

The next step after being able to apply a transformation to a tree or all of its children is to expand this to the AST as a whole. We can distinguish between two fundamental ways of transforming a tree: either in a pre-order or post-order fashion.

\paragraph{Pre-Order} \hfill $\downarrow: (A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} Pre-order application of a transformation applies the transformation to the parent first and then descends into its children. The consequence is that at the time a tree gets transformed, its children are still in their original, untransformed state.

\begin{lstlisting}
  def %$\downarrow$ \hspace{19pt} %      [A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = t &> allChildren(%$\downarrow$%(t))
  def preorder[A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = %$\downarrow$%(t)
\end{lstlisting}

Using a pre-order transformation has the benefit that trees are always in their original state when they are transformed, this can be used when the trees need to be compared for equality. A disadvantage is that a transformation can diverge when it modifies a tree so that it again applies to one of its new children. For example, applying the following transformation to a tree results in a stack overflow when applied with pre-order traversal:

\begin{lstlisting}
transformation[Tree, Tree] {
  case block @ Block(stats, _) => block copy (stats = block :: stats)
}
\end{lstlisting}

This will not happen when the transformation is applied using post-order traversal.

\paragraph{Post-Order} \hfill $\uparrow: (A \overset{t}{\rightarrow} [A]) \Rightarrow (A \overset{t}{\rightarrow} [A])$

\vspace{7pt} Bottom-up application first descends into the children of a tree and processes the parent after the children. Thus once a tree gets transformed, its children have already been transformed.

\begin{lstlisting}
  def %$\uparrow$ \hspace{27pt} %      [A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = allChildren(%$\uparrow$%(t)) &> t
  def postorder [A <%\%% (A %$\Rightarrow$% A) %$\Rightarrow$% A](t: Transformation[A, A]) = %$\uparrow$%(t)
\end{lstlisting}

Combining all these transformations with combinators and traversal strategies allows us to describe transformations in a very concise way.

\figref{figure:traversal_mode} illustrates the difference between the two traversal modes.

\begin{figure}
 \centering
 \includegraphics[width=0.4\linewidth]{traversal_mode.pdf}
 \caption{An illustration of the pre- and post-order traversal strategies: the blue points show the order in which the tree gets transformed in pre-order traversal, and the green ones illustrate the post-order traversal. Instead of pre- and post-order, we can also think of the transformations being applied top-down or bottom-up, hence the $\downarrow$ and $\uparrow$ aliases.}
 \label{figure:traversal_mode}
\end{figure}

As a first example, let us write and use a transformation that replaces all trees in the AST which do not have a range position with the \src{EmptyTree}.

\begin{lstlisting}
val tree: Tree = %\ldots%

val emptyTree = transformation[Tree, Tree] {
  case t if t.pos.isRange => t
  case _ => EmptyTree
}

preorder(allChildren(emptyTree)) apply tree
\end{lstlisting}

Preorder traversal already applies the transformation to all children, so we can simplify this to:

\begin{lstlisting}
preorder(emptyTree) apply tree
\end{lstlisting}

Of course, this is not the only way to achieve this, here is a variation that separates the testing for the range position into a predicate and uses a simple transformation to replace the tree. If the tree has a range position, it is not transformed (remember that the \src{id} transformation simply returns its argument unchanged). In case the predicate fails, the tree is replaced.

\begin{lstlisting}
val hasRangePosition = predicate((t: Tree) => t.pos.isRange)

val emptyTree = transformation[Tree, Tree] {
  case _ => EmptyTree
}

preorder(hasRangePosition &> id[Tree] |> emptyTree) apply tree
\end{lstlisting}

Using the \src{not} combinator, we can swap the two actions:

\begin{lstlisting}
preorder(not(hasRangePosition) &> emptyTree |> id[Tree]) apply tree
\end{lstlisting}

To get rid of the \src{id} transformation, we can use a different traversal strategy for the children:

\begin{lstlisting}
preorder(matchingChildren(not(hasRangePosition) &> emptyTree)) apply tree
\end{lstlisting}

More examples can be found in Section \vref{subsection:tree-transformations}.

\subsection{Creating Trees}

Most refactorings do not just reuse existing trees but also have to create new ones. The Scala compiler already contains several facilities to create new trees: the trait \src{scala.tools.nsc.ast.Trees} contains many methods that create AST trees and there's even a DSL in \src{scala.tools.nsc.ast.TreeDSL} whose ``goal is that the code generating code should look a lot like the code it generates''.

An example from \src{Trees} shows how many methods there are to create method definitions (this code has obviously been written before Scala had default arguments):

\begin{lstlisting}
def DefDef(sym: Symbol, mods: Modifiers, vparamss: List[List[ValDef]], rhs: Tree): DefDef

def DefDef(sym: Symbol, vparamss: List[List[ValDef]], rhs: Tree): DefDef
  
def DefDef(sym: Symbol, mods: Modifiers, rhs: Tree): DefDef

def DefDef(sym: Symbol, rhs: Tree): DefDef

def DefDef(sym: Symbol, rhs: List[List[Symbol]] => Tree): DefDef
\end{lstlisting}

Using the TreeDSL allows one to write very concise code. The following listing creates the AST for the code that checks whether \src{tree} is null.

\begin{lstlisting}
IF (tree MEMBER_== NULL) THEN %\ldots% ELSE %\ldots%
\end{lstlisting}

Unfortunately, all these tree construction helpers are problematic for us: they can change the position of the trees, which we have to avoid when we want to retain the source code layout. For this reason, the refactorings do not make use of these facilities but simply create the trees from scratch. There are some helper methods in \src{transformation.TreeFactory} which take care of constructing trees that are needed by the currently implemented refactorings:

\begin{lstlisting}
def mkRenamedSymTree(t: SymTree, name: String): SymTree

def mkReturn(s: List[Symbol]): Tree

def mkValDef(name: String, rhs: Tree): ValDef

def mkCallDefDef(name: String, arguments: List[List[Symbol]], 
  returns: List[Symbol]): Tree

def mkDefDef(mods: Modifiers, name: String, 
  parameters: List[List[Symbol]], body: List[Tree]): DefDef

def mkBlock(trees: List[Tree]): Block
\end{lstlisting}

Now that we have seen how trees can be transformed and how new trees can be generated, we are ready for a larger example.

\subsection{Tree Transformations}\label{subsection:tree-transformations}

For the usage in the refactoring, the \src{TreeTransformations} trait implements the traversal for Scala's AST and provides some definitions that make writing transformations more concise:

\begin{lstlisting}
def transform(f: PartialFunction[Tree, Tree]) = transformation(f)
  
def filter(f: %$\Rightarrow$% PartialFunction[Tree, Boolean]) = predicate(f)
\end{lstlisting}

Let us now take a look at a larger example: Extract Method. At the beginning of this section, we looked at the different transformations that occur during the refactoring: Insert a new method with the extracted statements and replace them with a call to this new method. This can be achieved with the following transformations:

\begin{lstlisting}
val replaceBlockOfStatements = transform {
  case block @ BlockExtractor(stats) => {
    mkBlock(stats.replaceSequence(selectedTrees, callExtractedMethod))
  }
}

val replaceSingleExpression = transform {
    case t if t == selectedTree => callExtractedMethod
}

val replace = topdown {
  matchingChildren {
    if(extractSingleTree)
      replaceSingleExpression
    else
      replaceBlockOfStatements
  }
}

val insertExtractedMethod = transform {
  case tpl @ Template(_, _, body) => 
    tpl copy (body = body ::: extractedMethod :: Nil) setPos tpl.pos
}
\end{lstlisting}

A remark on the call to \src{setPos tpl.pos} in \src{insertExtractedMethod}: Because the structure of a tree is immutable, we cannot change a tree in-place, even though we often want to do this. The source regeneration uses the position information of the trees to determine whether a tree's existing source code can be reused. So if we want a tree to appear modified in-place, we simply assign it the position of the original tree. Note that this does only work if the two trees are of the same type.

Next we need two filters that find the enclosing class' template and the method we extract from:

\begin{lstlisting}
val findTemplate = filter {
  case Template(_, _, body) => body exists (_ == selectedMethod)
}

val findMethod = filter {
  case d: DefDef => d == selectedMethod
}
\end{lstlisting}

Now we can combine these to assemble a new transformation that performs the following steps:

\begin{enumerate}
 \item Traverse the tree until the selected template is found, the one that contains \src{selectedMethod}.
 \item Once we found the template, start the following two transformations:
  \begin{enumerate}
        \item Find the method we extract from and apply the \src{replace} transformation on it.
        \item Insert the new method in the class template.
       \end{enumerate}
\end{enumerate}

%\includegraphics[width=\linewidth]{extract_method_transformation.pdf}

All these steps can be expressed with a simple transformation:

\begin{lstlisting}
val extractMethod = topdown {
  matchingChildren {
    findTemplate &> 
    topdown {
      matchingChildren {
	findMethod &> replace
      }
    } &> 
    insertExtractedMethod
  }
}
\end{lstlisting}

\section{Code Generation}

Once our abstract syntax tree has been refactored, we need to convert it back into its textual source code representation. This process comprises two main steps: the \textit{detection of modifications} to minimize the amount of code that is regenerated and the actual \textit{source generation}.

The first step is necessary because we -- in contrast to many other refactoring implementations -- do not keep track of modifications to the AST while they are happening but reconstruct this information afterwards. This allows us to keep the transformations simpler but consequently makes the code generation more complex. This tradeoff is worthwile because we intend the library to be reused and the transformations to be implemented by third parties.

The AST after the refactoring may contain several kinds of modifications. Trees can be moved around, deleted and new trees can be introduced. From the transformations we know that trees that are moved around keep their original position information, and newly created trees have a \src{NoPosition} attribute per default. This allows us to detect changes and can later be used during source generation to preserve the layout of already existing trees. 

\subsection{Modification Detection}

The primary goal of a fine-grained modification detection is to reduce the amount of trees that are regenerated. The source generation is invoked with a list of trees from various files that all can have an arbitrary number of changed children:

\begin{lstlisting}
def createChanges(ts: List[Tree]): Iterable[Change]
\end{lstlisting}

Modification detection performs the following three steps on the input trees:

\begin{enumerate}
 \item Group all changed trees by their file.
 \item Find the top-level changed trees for each file.
 \item Detect the change-set per top-level tree.
\end{enumerate}

Top-level trees are trees that are ancestors of other changed trees. For example, the following graph shows an AST with some changed trees in green and blue:

\begin{center}
\includegraphics[width=0.2\linewidth]{ast_with_changes.pdf}
\end{center}

The \src{createChanges} method is invoked with the two green trees, but the blue tree has also been modified by a transformation.

Now if we were to generate two changes from the two green trees, we would get a problem when applying the changes because they overlap each other. The two changes would either overwrite each other or, in the case of Eclipse's Language Toolkit, yield an error. Therefore the second step of the modification detection is to find those trees that contain other changed trees. In the AST above, this would be the root node.

The third step then traverses these top-level trees and finds all changes as well as the trees that lie between changed trees, here marked in blue:

\begin{center}
\includegraphics[width=0.2\linewidth]{ast_with_changeset.pdf}
\end{center}

This set of trees is the minimal number of trees that need to be regenerated. Trees that are not contained in the set can be kept as they are to improve the performance. \figref{figure:ast_with_changes_large} shows a larger example of the process.

\begin{figure}
 \centering
 \includegraphics[width=\linewidth]{./ast_with_changes_large.pdf}
 \caption{An example of how the change set is built: the left AST shows in green the list of all trees that should be regenerated, but the blue trees have changed as well. In the middle graph, we see the trees that were identified as top-level trees. The rightmost AST shows all trees that need to be regenerated.}
 \label{figure:ast_with_changes_large}
\end{figure}

Once we have identifier all top-level tree changes, we start generating source code for them. 

\subsection{Source Code Generation}

The AST does by its very nature not contain all the information that is necessary to fully reconstruct its original textual representation. Also, syntactic sugar of the programming language is usually not represented in the AST but only available in its generalized form. An example for this are Scala's \src{for} comprehensions. They are equivalent with function calls to \src{map, filter, flatMap,} and \src{foreach}. This means that the two statements in the following listing have the same representation in the AST.

\begin{lstlisting}
val v1 = List(1,2,3) map (i => i * 2)
val v2 = for(i <- List(1,2,3)) yield i * 2
\end{lstlisting}

Other things that are not mentioned explicitly in the AST are parenthesis, commas and many other tokens. In the context of source generation, we will call them layout elements, or just \textit{layout}. 

If we were only interested in a semantically equivalent program, we could simply pretty print the AST to generate the source code. No user of a refactoring tool would accept this, so we need another technique. 

The source code is always available to the refactoring tool, and with the position information on the trees, we have a means to look up the original source code for a tree.

Other refactoring tools (TODO ref) have used various approaches to solve this problem. For some cases -- for example in a rename refactoring -- it might even be acceptable to pretty print the code as long as only very small regions of the program change. This approach can be problematic -- for example with the Extract Method refactoring, where arbitrary large parts of the program are moved around. A tool can handle this situation by cut-and-pasting the body of the extracted method. This is not feasible for us because we need a generic way to handle all kinds of unforseeable changes to the source code.

\subsubsection{Preserving Layout}

Our approach is based on using two different kinds of source printers: one that pretty prints code  and another one that reuses the existing code where possible. The \textit{pretty printer} simply prints the code with a default layout and is used for trees that were introduced during the transformation. The \textit{reusing printer} takes the existing layout with the help of the trees's position information and also makes sure all needed layout elements are present. How this is done will be explained in more detail later.

The source generation algorithm then alternates between these two printers during the code generation process.

Now we just need to know how we can reuse the existing layout. What we need is a way to decide how all these layout elements can be associated to their enclosing trees. If we take a look at the following listing, we can see several occurences of whitespace and other layout, like the three comments and the braces.

\begin{lstlisting}
package p //TODO
// myclass
class MyClass(a: Int /* the int */) {
}
\end{lstlisting}

Because no rules of the programming language dictate how the layout is associated with the other parts of the program, we have to guess how to divide it and associate it with its surrounding trees. Often this can be done by taking the types of the adjacent trees into consideration and then divide the layout according to some rules and regular expressions. 

For example, one rule says that the layout between two enclosing value definitions is split by a comma, or by newline if there is no comma present. So when the values are part of an argument list, they will get comma-separated, and if they are definitions, the layout will be split at the end of the line, so that the first value will get all layout that follows on its line. Comments can be handled with the same rules as well: a comment on a preceding and otherwise empty line is associated with the following tree.

Let us take a look at a concrete example. \figref{figure:ast_with_layout} shows the AST of the previous listing and how the layout elements have been associated with the left and right sides of a tree. Note that the \src{class} and \src{package} keywords are also considered layout, this is because they are not represented in the AST with their own tree and position information.

\begin{figure}
 \centering
 \includegraphics[width=0.8\linewidth]{ast_with_layout.pdf}
 \caption{An example of how layout can be associated with trees: the apricot colored boxes represent the trees and the green ones their associated layout. The blue parts are not real AST nodes but names; they are treated like trees in the source generation.}
 \label{figure:ast_with_layout}
\end{figure}

Once we have identified the layout that belongs to a tree, we can use it during the source generation. For example, it should be clear now that when we would delete the \src{ValDef} parameter in the above AST, then the comment would be removed along with it.

Another issue that concerns both the pretty and the reusing printer is the indentation of the code. When a new statement in a block of other statements is inserted, we want it to have the same indentation as its siblings. For this, the printers also keep track of the currently desired indentation as specified by the parent tree. 

Whether we can reuse existing code or have to invoke the pretty printed needs to be decided for each tree in the AST. This gives us the following definition of the various source printers:

\begin{lstlisting}
trait AbstractPrinter {
  def print(t: Tree, ind: Indentation): Fragment
}

trait PrettyPrinter extends AbstractPrinter {
  def print %\ldots%
}

trait ReusingPrinter extends AbstractPrinter {
  def print %\ldots%
}

trait SourceGen extends PrettyPrinter with ReusingPrinter {
  override def print(t: Tree, i: Indentation): Fragment = {
    if(t.hasExistingCode)
      super[ReusingPrinter].print(t, i)
    else if(t.hasNoCode)
      super[PrettyPrinter].print(t, i)
    else
      EmptyFragment
  }
%\ldots%
\end{lstlisting}

What we have not yet explained is the \src{Fragment} type.

\subsubsection{Fragments and Layout}

The result of a printing operation is not a plain string but an instance of \src{Fragment}. A fragment contains a leading, center, and trailing layout. A layout is simply a wrapper around a string or a part of the source file with some additional helper methods. For example, in \figref{figure:ast_with_layout}, all the apricot and blue colored boxes are fragments and the green ones are instances of \src{Layout}.

The fragments and layouts are created in the printers, where they pattern match on the tree and recursively print the children of a tree. This is an excerpt from the pretty printer:

\begin{lstlisting}
def print(t: Tree, ind: Indentation) = t match {
  case PackageDef(pid, stats) =>
    Layout("package ") ++ 
      printTree(pid, after = newline) ++ 
      printTrees(stats, separator = newline)
%\ldots%
\end{lstlisting}

The \src{++} operation on the layout and the fragments simply concatenate their operands, again yielding a fragment. So far, we could also have just used plain Strings and concatenate them with \src{+}, except that using strings weakens the typesystem because every object can be concatenated to a String using the implicit \src{toString} method.

\subsubsection{Reusing Layout}

The printers also have to take care that all the necessary layout is printed when needed. This can become difficult when layout is reused. Imagine the following scenario: We create a new \src{Block} (a \src{Block} tree wraps a list of other statements) and insert several statements into it. The pretty printer separates each statement in a block with a newline, so the code to pretty print a block could look like this:

\begin{lstlisting}
case Block(stats) =>
  Layout("{"+newline) ++ 
    printTree(stats, separator = newline) ++ 
    Layout(newline+"}")
\end{lstlisting}

This works fine as long as the statements are not reused trees that might already have a leading or trailing newline in their associated layout. If this is the case, we could get too many blank lines between our statements. 

To solve this, the pretty printer could print the block's children one by one and then check if the newline is already present or needs to be inserted. This is tedious to do in every place where a layout element is inserted, so we need a more generic way to handle such cases, and this is where the \src{Requisites} come into play. Instead of specifying the layout directly, the printers simply declare that there needs to be a newline present in the surrounding layout:

\begin{lstlisting}
case Block(stats) =>
  Requisite("{"+newline) ++ 
    printTree(stats, separator = Requisite(newline)) ++ 
    Requisite(newline+"}")
\end{lstlisting}

Now during the concatenation of fragments and layout objects with \src{++}, it is checked whether a certain requisite is already satisfied. The layout is only generated when it is nedeed.

This leads us to the following three interfaces (the \src{++} operators and some other methods have been omitted) that are used to represent the source code in the printers:

\begin{lstlisting}
trait Layout {
  def asText: String
}

trait Requisite {  
  def isRequired(l: Layout, r: Layout): Boolean
  def apply(l: Layout, r: Layout): Layout
}

trait Fragment {
  def leading:  Layout
  def center:   Layout
  def trailing: Layout
  
  def pre: Requisite
  def post: Requisite
  
  def asText: String
}
\end{lstlisting}

(hier muss noch was kommen, aber was? mehr beispiele?)

\subsection{Using the Source Generator}

To users of the code generation, the \src{createChanges} method of the \src{SourceGen} trait creates the change objects from a list of trees by first narrowing down the changed trees and then generating the code for them. The result is a list of change objects that describe which parts in a file are to be replaced.

\begin{lstlisting}
case class Change(file: AbstractFile, from: Int, to: Int, text: String)
\end{lstlisting}



\chapter{Refactoring Implementations}

describe each refactoring, with examples, problems, corner cases and the actual implementation. shows the library internals from the previous chapter in action.

\section{Rename}
\section{Organize Imports}
\section{Extract Method}
\section{Extract Local}


\chapter{Integration}

how can the refactorings be integrated into a new tool?
how does the current integration look like

\chapter{Testing}

don't describe the unit tests but show how the refactoring tests work and how one could write new test cases.

\chapter{Outlook}

\section{Acknowledgments}

I would like to thank ..

\section{Future Work}

what is left to do, how can the work be extended

\appendix

Scala terminology appendix

\chapter{User Guide}

User guide, also in HTML on the Wiki. Describes the usage of the implemented refactoring along with their shortcomings.

\chapter{Developer How-To}

A short introduction by example, for more depth, refer to the main documentation.

\include{9_appendix}
\include{91_scala_ast}

\clearpage
\bib

\end{document}
