\documentclass[10pt,a4paper,oneside]{scrreprt}
\usepackage{mystyle}

\begin{document}

\newcommand{\subtitlename}{Master's Thesis}
\newcommand{\titlename}{Refactoring Tool Support for Scala}

\include{0_front}

\emptypage

\chapter*{Abstract}

\pagenumbering{roman}

This thesis..


\chapter*{Management Summary}

This documentation 

\newpage

\setcounter{tocdepth}{2}

\tableofcontents

\newpage

\pagenumbering{arabic}

\chapter{Introduction} \label{chapter:introduction}

The goal of this thesis is to provide Scala developers with automated refactoring tools. This master's thesis is a continuation of a term project (see \cite{ScalaRefactoring}) at the University of Applied Sciences Rapperswil, Switzerland. In this chapter, we will motivate the grundlagendings: refactoring and the Scala programming language, and explain the goals of this thesis.

\section{Refactoring}

Refactoring of programs is a well established practice among professional software engineers. In his 1992 PhD thesis \cite{OpdykeThesis}, William Opdyke defined refactoring as 

\begin{quotation}
a set of program restructuring operations (refactorings) that support the design, evolution and reuse of object-oriented application frameworks.
\end{quotation}

The breakthrough in industry followed in 1999, when Martin Fowler and his colleagues published their popular book \textit{Refactoring: Improving the Design of Existing Code} \cite{FowlerRefactoring}, where refactoring is defined as 

\begin{quotation}
the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure.
\end{quotation} 

Today, refactoring has been absorbed by the programming mainstream, and is usually well integrated into the developer's work-flow and development environment. Developers use refactoring tools to keep their code maintainable by applying refactorings such as Rename to quickly change identifiers. In agile environments, where the program is rapidly adapted to handle new requirements, performing regular refactorings is essential to achieve reusable code and to keep up with the pace of change.

Refactoring as a technique does not mandate a tool nor depend on a specific programming language.

\section{Scala}

The Scala programming language \cite{ProgrammingScala}, developed by Martin Odersky and his team at EPFL, is a statically typed, compiled language that runs on the Java virtual machine (or on .NET alternatively \cite{ScalacNet}) and excels with its unique combination of object-oriented and functional programming concepts. It has also been called a postfunctional language because it has been designed ``to make functional constructs, imperative constructs, and objects all play well together'' \cite{ScalaPostFunctional}. 

One of Scala's strengths is its seamless interoperability with Java on the class level: Scala classes can extend Java classes and vice-versa. Scala also does not ship with a huge standard library but uses existing Java classes where it is sensible.

Scala provides all of Java's object-oriented features but does away with the non-object oriented ones like primitive types (?) and static class members. Scala also provides code reuse via traits, a kind of interface that can provide an implementation.

From functional programming, Scala has absorbed functions as first class values and embraces the idea of immutability with various language constructs. Scala even supports lazy evaluation through by-name parameters. A combination from both object-oriented and functional worlds can be seen in Scala's ability to use pattern matching to deconstruct objects while still preserving encapsulation.

These were just a few examples of how Scala differs from other languages such as Java. One last feature worth mentioning is that in Scala, building your own abstractions and control structures is easy, which is the reason why it has been named the ``scalable language''.

\section{Integrated Development Environments}

Many programmers, particularly of mainstream languages such as Java and C\#, use integrated development environments (IDE) to write their programs. Especially the IDEs for the Java programming language excel with automated refactoring support; the screen-shots in \figref{figure:ide_refactorings} show two examples. If Scala wants to cater to those programmers and become a viable alternative in enterprises, it needs to offer IDE support that is as comfortable to use and as mature as the existing Java tooling is.

Scala is supported on the three main Java development platforms Eclipse \cite{EclipseScalaIDE}, IntelliJ IDEA \cite{IntelliJScalaIDE}, and the NetBeans \cite{NetBeansJScalaIDE}, but with the exception of IntelliJ IDEA -- which offers a few refactorings -- support for automated refactoring does not yet exist. Although a study by Emerson~Murphy-Hill et al. among developers using Eclipse \cite{RefactoringStudy} indicates that many refactorings are not performed with the tool support but by hand, other automated refactorings like Rename, Move and Extract Method are used frequently.

\begin{figure}
 \centering
 \includegraphics[width=0.7\linewidth]{ide_refactorings.png}
 \caption{Automated refactoring in Java IDEs}
 \label{figure:ide_refactorings}
\end{figure}

\section{Thesis Goals}

The goal of this thesis is to support Scala IDEs with automated refactoring support. It aims to provide a comprehensive catalogue of refactorings and the necessary infrastructure to create new refactorings. To let (?) as many IDEs and other tools as possible profit from the project, it will provide an IDE independent refactoring library that only depends on the Scala compiler. IDEs can then integrate this library by providing the user interface and interaction.

As most IDEs today are written in Java, integrating a Scala library is easily possible. Also, because the majority of Scala IDEs are open source (NetBeans, Eclipse), having a single refactoring library allows the developers to cooperate on an implementation, not fragmenting the already scarce resources any further. As a showcase, this project provides the integration into the Eclipse based Scala IDE \cite{EclipseScalaIDE}.

Writing an automated refactoring is no easy task, several things have to be taken care of: one has to analyze the source code, create an appropriate representation (e.g. abstract or concrete syntax tree) of the program, transform it and turn it back into plain source code. 

The heart of a refactoring is the transformation or manipulation of the program representation; but often (from our experience with refactoring tools for languages like Ruby \cite{RubyRefactoring}, C++ \cite{CdtOopsla}, and Groovy \cite{GroovyOopsla}) the developer also has to provide the instructions or hints on how these manipulations affect the source code. This makes creating new refactorings needlessly complex and is a high entry barrier for contributors. The Scala refactoring library tries to make creating new refactorings as simple as possible: code generation from the abstract syntax tree is implemented generically and needs no help from the refactoring writer.

Transformations of the program are based on the Scala compiler's own AST, and are written in a functional programming style that makes it possible to assemble complex transformations from simple ones.

To summarize, the Scala Refactoring project provides an IDE independent refactoring library which makes creating new refactorings as simple as possible.

welche refactorings

(Sollte hier noch mehr kommen? Z.B. mehr \"uber die Resultate? Eigentlich m\"ochte ich das im Outlook besprechen, aber vielleicht geh\"ort es auch schon hier hin.)

\section{Contents of This Report}

This document is organized as follows: Chapter~\vref{chapter:refactoring-library} explains the concepts and implementation of the refactoring library. The details of the implemented refactorings are described in Chapter~\vref{chapter:implemented-refactorings}. How these refactorings can be integrated into an IDE or other tool is the topic of Chapter~\vref{chapter:tool-integration}. How the implemented refactorings are tested is explained in Chapter~\vref{chapter:testing}. Chapter~\vref{chapter:outlook} concludes this thesis with a review of the achievements and an outlook on further work.

The appendices contain a user guide to the refactorings in Eclipse (Appendix~\vref{chapter:user-guide}), ...

\vref{chapter:developer-how-to}

\vref{chapter:project-environment}

\vref{chapter:advanced-scala-features}

\vref{chapter:scala-ast}

\include{2_refactoring_library}

\chapter{Implemented Refactorings} \label{chapter:implemented-refactorings}

describe each refactoring, with examples, problems, corner cases and the actual implementation. shows the library internals from the previous chapter in action.

\section{Rename}
\section{Organize Imports}
\section{Extract Method}
\section{Extract Local}
\section{Explicit Getters And Setters}


\chapter{Tool Integration} \label{chapter:tool-integration}

how can the refactorings be integrated into a new tool?
how does the current integration look like

\chapter{Testing} \label{chapter:testing}

The necessity of automated testing in modern software projects bears no repetition. Especially with a project that is so intrinsically dependent on another component -- the Scala compiler -- and its internals, having a strong suite of integration tests is essential. The following chapter shows how the refactoring integration tests are implemented with the goal to provide a guide for creating new tests.

\section{Compiler}

When the refactoring implementations are used, the IDE or more generally the invoking tool provides access to the compiler. The refactoring themselves do not posses the ability to parse the code. In the tests, we therefore also have to provide a compiler that parses and type-checks our test code.

Because instantiating and initializing the compiler is a rather expensive operation, one compiler instance is shared among all the tests. The \src{CompilerProvider} trait shown below gives us access to this instance and provides functionality to turn a string into a fully typed \src{Tree} instance and to add a file in the form of a string to the compiler:

\begin{lstlisting}
trait CompilerProvider {

  val global = CompilerInstance.compiler
    
  def treeFrom(src: String): global.Tree = %\ldots%
  
  def addToCompiler(name: String, src: String): AbstractFile = %\ldots%
}
\end{lstlisting}

Sharing a compiler instance is not without problems: because all the compilation units end up in the same compiler, this might result in conflicts. But this can easily be avoided by putting the individual test cases into their own package.

\section{Creating a Project Layout}

Now that we have a compiler, we need a way to represent Scala source files and combine them to a something like a project. Thanks to Scala's support for raw strings, we can embed the Scala source code directly in our test cases and do not have to store them in external files or concatenate strings together. So in our test cases we can construct an AST from a string like this:

\begin{lstlisting}
val tree: global.Tree = treeFrom("""
  object Main {
    def main(args: Array[String]) {
    }
  }
""")
\end{lstlisting}

The \src{FileSet} class can be used to represent a Scala test project. It has an implicit conversion (see Appendix \vref{section:implicit-conversions}) method that adds the \src{becomes} method to \src{String} so it can be used as follows:

\begin{lstlisting}
val project = new FileSet {
  """
    Content of this source file.
  """ becomes
  """
    Expected test result for this file.
  """;

  "a second source file" becomes " %\ldots% "
}
\end{lstlisting}

The \src{FileSet} class also contains a method \src{applyRefactoring} that takes a function from \src{FileSet} to \src{List[Change]} which it uses to turn the specified source files into a list of changes. The changes are then applied to the sources and their result compared to the expected results using the standard JUnit asserts.

\section{Implementation}

Taking a look at a test for the \src{Organize Imports} refactoring, the result looks as follows:

\begin{lstlisting}
@Test
def sortImportsByName = new FileSet {
  """
    import scala.collection.mutable.ListBuffer
    import java.lang.Object

    object Main
  """ becomes
  """
    import java.lang.Object
    import scala.collection.mutable.ListBuffer

    object Main
  """
} applyRefactoring %\textbf{organize}%
\end{lstlisting}

The \src{organize} function simply instantiates the concrete refactoring and performs it, returning the list of changes the refactoring generated. Organize Imports is a very simple refactoring because it needs neither a selection from the user nor any other configuration. A test case for the Rename refactoring can be seen in the following listing:

\begin{lstlisting}
@Test
def renameSelfType = new FileSet {
  """
  trait /*(*/T1/*)*/

  trait T3 {
    self: T1 =>

  }""" becomes
  """
  trait /*(*/Trait/*)*/

  trait T3 {
    self: Trait =>

  }"""
} applyRefactoring %\textbf{renameTo}%("Trait")
\end{lstlisting}

The selection is indicated by the two comments \src{/*(*/} and \src{/*)*/}. The comments remain in the source code, this is why we also see them in the expected result. With the help of Scala's multiple argument lists and partial application of functions, the \src{renameTo} function can be implemented like this:

\begin{lstlisting}
def renameTo(name: String)(pro: FileSet): List[Change] = %\ldots%
\end{lstlisting}

%The structure of the test packages follows the main library.

\chapter{Outlook} \label{chapter:outlook}

\section{Accomplishments}

XXX needs some kind of conclusion, we have achieved our goal of having source generation that doesn't need user interaction.

other usages (Richard?)


\section{Acknowledgments}

I would like to thank ..

\section{Future Work}

what is left to do, how can the work be extended

\appendix

\chapter{User Guide} \label{chapter:user-guide}

User guide, also in HTML on the Wiki. Describes the usage of the implemented refactoring along with their shortcomings.

\chapter{Developer How-To} \label{chapter:developer-how-to}

A short introduction by example, for more depth, refer to the main documentation.

\include{9_appendix}

\include{91_scala_ast}

\clearpage
\bib

\end{document}


