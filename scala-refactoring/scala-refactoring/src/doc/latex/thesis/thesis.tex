\documentclass[10pt,a4paper,oneside]{scrreprt}
\usepackage{mystyle}

\begin{document}

\newcommand{\subtitlename}{Master's Thesis}
\newcommand{\titlename}{Refactoring for Scala}

\include{0_front}

\chapter*{Abstract}

\pagenumbering{roman}

This thesis..


\chapter*{Management Summary}

This documentation 

\newpage

\setcounter{tocdepth}{2}

\tableofcontents

\newpage

\pagenumbering{arabic}

\chapter{Introduction}
\section{Problem Outline}
\section{Thesis Goals}

\include{2_refactoring_library}

\chapter{Refactoring Implementations}

describe each refactoring, with examples, problems, corner cases and the actual implementation. shows the library internals from the previous chapter in action.

\section{Rename}
\section{Organize Imports}
\section{Extract Method}
\section{Extract Local}


\chapter{Integration}

how can the refactorings be integrated into a new tool?
how does the current integration look like

\chapter{Testing}

The necessity of automated testing in modern software projects bears no repetition. Especially with a project that is so intrisically dependent on another component -- the Scala compiler -- and its internals, having a strong suite of integration tests is essential. The following chapter shows how the refactoring integration tests are implemented with the goal to provide a guide for creating new tests.

\section{Compiler}

When the refactoring implementations are used, the IDE or more generally the invoking tool provides access to the compiler. The refactoring themselves do not posess the ability to parse the code. In the tests, we therefore also have to provide a compiler that parses and typechecks our test code.

Because instantiating and initializing the compiler is a rather expensive operation, one compiler instance is shared among all the tests. The \src{CompilerProvider} trait shown below gives us access to this instance and provides functionality to turn a string into a fully typed \src{Tree} instance and to add a file in the form of a string to the compiler:

\begin{lstlisting}
trait CompilerProvider {

  val global = CompilerInstance.compiler
    
  def treeFrom(src: String): global.Tree = %\ldots%
  
  def addToCompiler(name: String, src: String): AbstractFile = %\ldots%
}
\end{lstlisting}

Sharing a compiler instance is not without problems: because all the compilation units end up in the same compiler, this might result in conflicts. But this can easily be avoided by putting the individual test cases into their own package.

\section{Creating a Project Layout}

Now that we have a compiler, we need a way to represent Scala source files and combine them to a something like a project. Thanks to Scala's support for raw strings, we can embed the Scala source code directly in our test cases and do not have to store them in external files or concatenate strings together. So in our test cases we can construct an AST from a string like this:

\begin{lstlisting}
val tree: global.Tree = treeFrom("""
  object Main {
    def main(args: Array[String]) {
    }
  }
""")
\end{lstlisting}

The \src{FileSet} class can be used to represent a Scala test project. It has an implicit conversion (see Appendix \vref{section:implicit-conversions}) method that adds the \src{becomes} method to \src{String} so it can be used as follows:

\begin{lstlisting}
val project = new FileSet {
  """
    Content of this source file.
  """ becomes
  """
    Expected test result for this file.
  """;

  "a second source file" becomes " %\ldots% "
}
\end{lstlisting}

The \src{FileSet} class also contains a method \src{applyRefactoring} that takes a function from \src{FileSet} to \src{List[Change]} which it uses to turn the specified source files into a list of changes. The changes are then applied to the sources and their result compared to the expected results using the standard JUnit asserts.

\section{Implementation}

Taking a look at a test for the \src{Organize Imports} refactoring, the result looks as follows:

\begin{lstlisting}
@Test
def sortImportsByName = new FileSet {
  """
    import scala.collection.mutable.ListBuffer
    import java.lang.Object

    object Main
  """ becomes
  """
    import java.lang.Object
    import scala.collection.mutable.ListBuffer

    object Main
  """
} applyRefactoring %\textbf{organize}%
\end{lstlisting}

The \src{organize} function simply instantiates the concrete refactoring and performs it, returning the list of changes the refactoring generated. Organize Imports is a very simple refactoring because it needs neither a selection from the user nor any other configuration. A test case for the Rename refactoring can be seen in the following listing:

\begin{lstlisting}
@Test
def renameSelfType = new FileSet {
  """
  trait /*(*/T1/*)*/

  trait T3 {
    self: T1 =>

  }""" becomes
  """
  trait /*(*/Trait/*)*/

  trait T3 {
    self: Trait =>

  }"""
} applyRefactoring %\textbf{renameTo}%("Trait")
\end{lstlisting}

The selection is indicated by the two comments \src{/*(*/} and \src{/*)*/}. The comments remain in the source code, this is why we also see them in the expected result. With the help of Scala's multiple argument lists and partial application of functions, the \src{renameTo} function can be implemented like this:

\begin{lstlisting}
def renameTo(name: String)(pro: FileSet): List[Change] = %\ldots%
\end{lstlisting}

%The structure of the test packages follows the main library.

\chapter{Outlook}

\section{Accomplishments}

XXX needs some kind of conclusion, we have achieved our goal of having source generation that doesn't need user interaction.


\section{Acknowledgments}

I would like to thank ..

\section{Future Work}

what is left to do, how can the work be extended

\appendix

Scala terminology appendix

\chapter{User Guide}

User guide, also in HTML on the Wiki. Describes the usage of the implemented refactoring along with their shortcomings.

\chapter{Developer How-To}

A short introduction by example, for more depth, refer to the main documentation.

\include{9_appendix}

\chapter{Advanced Scala Features}

This documentation does not introduce the reader to the Scala language, so an understanding of the basic concepts is assumed. This appendix explains some of the more advanced features and patterns of Scala that are used during the explanations in this document.

\section{Path Dependent Types} \label{section:path-dependent-types}

Path dependent types are best shown with an example (taken from Programming Scala \cite{ProgrammingScala}). We have an \src{Animal} class with an abstract type member called \src{SuitableFood} which is then defined in the subclasses to a suitable type.
\begin{lstlisting}
abstract class Food

abstract class Animal {
  type SuitableFood <: Food
  def eat(food: SuitableFood)
}

class Grass extends Food
class Cow extends Animal {
  type SuitableFood = Grass
  def eat(food: Grass) {}
}

class DogFood extends Food
class Dog extends Animal {
  type SuitableFood = DogFood
  def eat(food: DogFood) {}
}
\end{lstlisting}

This now prevents us from feeding the wrong kind of food to our animals:

\begin{lstlisting}
scala> val bessy = new Cow
bessy: Cow = Cow@3fb01949

scala> val lassie = new Dog
lassie: Dog = Dog@46c9220

scala> lassie eat (new bessy.SuitableFood)
<console>:14: error: type mismatch;
 found   : Grass
 required: DogFood
       lassie eat (new bessy.SuitableFood)
\end{lstlisting}

In the context of the Scala compiler, all instances of \src{Tree} are dependent on the compiler -- that is, impossible to mix trees from different compiler instances.

\begin{lstlisting}
trait Trees {
  %\ldots%
  abstract class Tree extends Product {
  %\ldots%
}
\end{lstlisting}

The Scala Refactoring library follows this design, all functionality that operates on compiler dependent types is in traits that have a compiler instance as an abstract member, like for example in the \src{AbstractPrinter} or the \src{Indexes}:

\begin{lstlisting}
trait AbstractPrinter {
  val global: scala.tools.nsc.interactive.Global
  import global._
  %\ldots%
}

trait Indexes {
  val global: scala.tools.nsc.interactive.Global
  %\ldots%
}
\end{lstlisting}

The user of the refactoring library then has to provide this abstract member and all implemented traits share the same instance. In the automated tests, this is done by the \src{CompilerProvider} trait.

\section{Stackable Traits} \label{section:stackable-traits}

Stackable traits are similar to the decorator design pattern, except that they do not decorate objects at run-time but other traits at compile-time. Assume that we have a trait that allows us to log events and an implementation that logs to the standard output:

\begin{lstlisting}
trait Logging {
  def log(severity: Int, msg: String): Unit
}

class ConsoleLogger extends Logging {
  def log(severity: Int, msg: String) = {
    println("%\%%d: %\%%s" format (severity, msg))
  }
}
\end{lstlisting}

What if we want to have a logger that only logs certain severities? Or one that filters the messages? We could subclass \src{ConsoleLogger}, but there are potentially many concrete loggers, and we want the user of the logger to be able to combine these features as he likes. This is where stackable traits are useful. Stackable traits use the \src{abstract override} modifier to override an abstract method and are then allowed to call \src{super} in the implementation, even though the super method is not really there.

\begin{lstlisting}
trait LogOnlyErrors extends Logging {
  abstract override def log(severity: Int, msg: String) {
    if(severity >= 3)
      super.log(severity, msg)
  }
}

trait TreatAllAsErrors extends Logging {
  abstract override def log(severity: Int, msg: String) {
    super.log(3, msg)
  }
}
\end{lstlisting}

What happens now is that the concrete method implementing \src{log} is called, or in case multiple such traits are extended, the next \src{abstract override} is called. This allows us to instantiate a logger in various variations. Because of Scala's trait linearization, the order of the stackable traits is significant and allows further combinations.

\begin{lstlisting}
scala> val logger = new ConsoleLogger with TreatAllAsErrors with LogOnlyErrors  
logger: ConsoleLogger with TreatAllAsErrors with LogOnlyErrors = $anon$1@8aee908

scala> logger.log(1, "Something insignificant happened.")

scala> logger.log(4, "A critical error, severity 4!")
3: A critical error, severity 4!

scala> val logger2 = new ConsoleLogger with LogOnlyErrors with TreatAllAsErrors
logger2: ConsoleLogger with LogOnlyErrors with TreatAllAsErrors = $anon$1@2a788315

scala> logger2.log(1, "Something insignificant happened.")
3: Something insignificant happened.

scala> logger2.log(1, "A critical error, severity 4!")
3: A critical error, severity 4!
\end{lstlisting}

\section{Implicit Conversions} \label{section:implicit-conversions}

Implicit conversions (also known as the \textit{pimp my library} pattern) can be used to (seemingly) add new methods to an existing class. 



This is also how Scala enriches Java's built-in types or why we can form tuples from any two objects:



\section{Self Type Annotation} \label{section:self-type-annotation}

In this case, think of the self type annotation as an alias for \src{this} that can be used in the body of the class. 

\include{91_scala_ast}

\clearpage
\bib

\end{document}

