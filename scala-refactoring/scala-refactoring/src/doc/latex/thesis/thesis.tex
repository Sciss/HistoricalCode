\documentclass[10pt,a4paper,oneside]{scrreprt}
\usepackage{mystyle}

\begin{document}

\newcommand{\subtitlename}{Master's Thesis}
\newcommand{\titlename}{Scala Refactoring}

\include{0_front}

\emptypage

\chapter*{Abstract}

\pagenumbering{roman}

This thesis..


\chapter*{Management Summary}

This documentation 

\newpage

\setcounter{tocdepth}{2}

\tableofcontents

\newpage

\pagenumbering{arabic}

\chapter{Introduction} \label{chapter:introduction}

The goal of this thesis is to provide Scala developers with automated refactoring tools. This master's thesis is a continuation of a term project (see \cite{ScalaRefactoring}) at the University of Applied Sciences Rapperswil, Switzerland. In this chapter, we will motivate the grundlagendings: refactoring and the Scala programming language, and explain the goals of this thesis.

\section{Refactoring}

Refactoring of programs is a well established practice among professional software engineers. In his 1992 PhD thesis \cite{OpdykeThesis}, William Opdyke defined refactoring as 

\begin{quotation}
a set of program restructuring operations (refactorings) that support the design, evolution and reuse of object-oriented application frameworks.
\end{quotation}

The breakthrough in industry followed in 1999, when Martin Fowler and his colleagues published their popular book \textit{Refactoring: Improving the Design of Existing Code} \cite{FowlerRefactoring}, where refactoring is defined as 

\begin{quotation}
the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure.
\end{quotation} 

Today, refactoring has been absorbed by the programming mainstream, and is usually well integrated into the developer's work-flow and development environment. Developers use refactoring tools to keep their code maintainable by applying refactorings such as Rename to quickly change identifiers. In agile environments, where the program is rapidly adapted to handle new requirements, performing regular refactorings is essential to achieve reusable code and to keep up with the pace of change.

Refactoring as a technique does not mandate a tool nor depend on a specific programming language.

\section{Scala}

The Scala programming language \cite{ProgrammingScala}, developed by Martin Odersky and his team at EPFL, is a statically typed, compiled language that runs on the Java virtual machine (or on .NET alternatively \cite{ScalacNet}) and excels with its unique combination of object-oriented and functional programming concepts. It has also been called a postfunctional language because it has been designed ``to make functional constructs, imperative constructs, and objects all play well together'' \cite{ScalaPostFunctional}. 

One of Scala's strengths is its seamless interoperability with Java on the class level: Scala classes can extend Java classes and vice-versa. Scala also does not ship with a huge standard library but uses existing Java classes where it is sensible.

Scala provides all of Java's object-oriented features but does away with the non-object oriented ones like primitive types (?) and static class members. Scala also provides code reuse via traits, a kind of interface that can provide an implementation.

From functional programming, Scala has absorbed functions as first class values and embraces the idea of immutability with various language constructs. Scala even supports lazy evaluation through by-name parameters. A combination from both object-oriented and functional worlds can be seen in Scala's ability to use pattern matching to deconstruct objects while still preserving encapsulation.

These were just a few examples of how Scala differs from other languages such as Java. One last feature worth mentioning is that in Scala, building your own abstractions and control structures is easy, which is the reason why it has been named the ``scalable language''.

\section{Integrated Development Environments}

Many programmers, particularly of mainstream languages such as Java and C\#, use integrated development environments (IDE) to write their programs. Especially the IDEs for the Java programming language excel with automated refactoring support; the screen-shots in \figref{figure:ide_refactorings} show two examples. If Scala wants to cater to those programmers and become a viable alternative in enterprises, it needs to offer IDE support that is as comfortable to use and as mature as the existing Java tooling is.

Scala is supported on the three main Java development platforms Eclipse \cite{EclipseScalaIDE}, IntelliJ IDEA \cite{IntelliJScalaIDE}, and the NetBeans \cite{NetBeansJScalaIDE}, but with the exception of IntelliJ IDEA -- which offers a few refactorings -- support for automated refactoring does not yet exist. Although a study by Emerson~Murphy-Hill et al. among developers using Eclipse \cite{RefactoringStudy} indicates that many refactorings are not performed with the tool support but by hand, other automated refactorings like Rename, Move and Extract Method are used frequently.

\begin{figure}
 \centering
 \includegraphics[width=0.7\linewidth]{ide_refactorings.png}
 \caption{Automated refactoring in Java IDEs}
 \label{figure:ide_refactorings}
\end{figure}

\section{Thesis Goals}

The goal of this thesis is to support Scala IDEs with automated refactoring support. It aims to provide a comprehensive catalogue of refactorings and the necessary infrastructure to create new refactorings. To let (?) as many IDEs and other tools as possible profit from the project, it will provide an IDE independent refactoring library that only depends on the Scala compiler. IDEs can then integrate this library by providing the user interface and interaction.

As most IDEs today are written in Java, integrating a Scala library is easily possible. Also, because the majority of Scala IDEs are open source (NetBeans, Eclipse), having a single refactoring library allows the developers to cooperate on an implementation, not fragmenting the already scarce resources any further. As a showcase, this project provides the integration into the Eclipse based Scala IDE \cite{EclipseScalaIDE}.

Writing an automated refactoring is no easy task, several things have to be taken care of: one has to analyze the source code, create an appropriate representation (e.g. abstract or concrete syntax tree) of the program, transform it and turn it back into plain source code. 

The heart of a refactoring is the transformation or manipulation of the program representation; but often (from our experience with refactoring tools for languages like Ruby \cite{RubyRefactoring}, C++ \cite{CdtOopsla}, and Groovy \cite{GroovyOopsla}) the developer also has to provide the instructions or hints on how these manipulations affect the source code. This makes creating new refactorings needlessly complex and is a high entry barrier for contributors. The Scala refactoring library tries to make creating new refactorings as simple as possible: code generation from the abstract syntax tree is implemented generically and needs no help from the refactoring writer.

Transformations of the program are based on the Scala compiler's own AST, and are written in a functional programming style that makes it possible to assemble complex transformations from simple ones.

To summarize, the Scala Refactoring project provides an IDE independent refactoring library which makes creating new refactorings as simple as possible.

welche refactorings

(Sollte hier noch mehr kommen? Z.B. mehr \"uber die Resultate? Eigentlich m\"ochte ich das im Outlook besprechen, aber vielleicht geh\"ort es auch schon hier hin.)

\section{Contents of This Report}

This document is organized as follows: Chapter~\vref{chapter:refactoring-library} explains the concepts and implementation of the refactoring library. The details of the implemented refactorings are described in Chapter~\vref{chapter:implemented-refactorings}. How these refactorings can be integrated into an IDE or other tool is the topic of Chapter~\vref{chapter:tool-integration}. How the implemented refactorings are tested is explained in Chapter~\vref{chapter:testing}. Chapter~\vref{chapter:outlook} concludes this thesis with a review of the achievements and an outlook on further work.

The appendices contain a user guide to the refactorings in Eclipse (Appendix~\vref{chapter:user-guide}), ...

\vref{chapter:developer-how-to}

\vref{chapter:project-environment}

\vref{chapter:advanced-scala-features}

\vref{chapter:scala-ast}

\chapter{Refactoring Library} \label{chapter:refactoring-library}

\include{2_refactoring_library}

\chapter{Implemented Refactorings} \label{chapter:implemented-refactorings}

The previous chapter explained the internals of the Scala Refactoring library; in this chapter, we shall take a look at the refactorings that have so far been implemented on top of the library. 

The three components of the refactoring library -- analysis, transformation, and source generation -- can be used independently from each other, but they also have dependencies expressed through self type annotations. The \src{Refactoring} trait combines the library with their dependencies and can be used as an entry point by library users.

\begin{lstlisting}
trait Refactoring extends Selections with TreeTransformations with SilentTracing 
    with SourceGenerator with PimpedTrees {
  %\ldots%
}
\end{lstlisting}

Performing a refactoring is not a single-step process: when the user invokes a refactoring, the first step is to check whether the refactoring can be applied -- for example, to perform a renaming, a name has to be selected. We call this the \textit{prepare} step. This step usually has a result, which is used in a configuration dialog to parameterize the refactoring. In our renaming example, this is the new name. Using the information from the preparation step and the configured parameters, the refactoring can then be \textit{performed}. This yields either a list of changes to be applied or it can also fail. See  \figref{figure:refactoring-sequence} for a visualization.

These steps are represented by the abstract class \src{MultiStageRefactoring}, which is subclassed by all concrete refactoring implementations:

\begin{lstlisting}
abstract class MultiStageRefactoring extends Refactoring {
  
  type PreparationResult
  
  case class PreparationError(cause: String)

  def prepare(s: Selection): Either[PreparationError, PreparationResult]

  
  type RefactoringParameters
  
  case class RefactoringError(cause: String)
  
  def perform(selection: Selection, prepared: PreparationResult, params: RefactoringParameters)
    : Either[RefactoringError, List[Change]]
}
\end{lstlisting}

The reason why the selection and the preparation results need to be passed to \src{perform} is to keep it stateless. This makes it much easier for an IDE to let the user going back and forwards and testing different configurations.

The remainder of this chapter introduces each refactoring and explains the current implementation for the Eclipse Scala IDE with examples. 

\section{Rename}

Renaming is one of the most used refactorings (see \cite{RefactoringStudy}, \cite{RefactoringInEclipse}). Choosing good names is a very basic and yet important task for a programmer if he wants to get readable code. During the evolution of a program, the roles of the classes, methods and variables change. Having an automated refactoring for renaming considerably reduces the cost of keeping these names in sync with what they do.

\subsection{Features}

This implementation supports renaming of all identifiers that occur in the program -- for example, local values and variables, method definitions and parameters, class fields, variable bindings in pattern matches, classes, objects, traits, packages, and types parameters.

The IDE implementation distinguishes between two different modes: inline renaming as shown in \figref{figure:rename-screenshot-1} and the traditional dialog based implementation in \figref{figure:rename-screenshot-2}. Inline renaming is implemented using Eclipse's linked mode user interface \cite{LinkedUI}.

\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{rename_screenshot_1.png}
  \caption{The Rename refactoring in the inline mode: the selected name along with all references can be renamed without the need of a wizard and without previewing the changes.}
  \label{figure:rename-screenshot-1}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{rename_screenshot_2.png}
  \caption{A classical Rename refactoring: All occurences of the selected name are changed across all files in the project.}
  \label{figure:rename-screenshot-2}
\end{figure}

Inline renaming is automatically chosen if the identifier that is renamed has only a local scope -- for example, a local variable. All names that can potentially be access from other compilation units in the program are renamed with the wizard and show a change set at the end.

\subsection{Implementation Details}

From the refactoring developer's point of view, the Rename refactoring is a quite different beast than other refactorings, because renaming does not change the shape of the AST at all; the transformations and source generation steps are trivial. On the other hand, having an accurate index is crucial; the inline rename refactoring uses only the index to find the locations of the names.

The implementation looks as follows:

\begin{lstlisting}
val occurences = index.occurences(prepared.selectedTree.symbol) 
    
val isInTheIndex = filter {
  case t: Tree %$\Rightarrow$% occurences contains t 
}

val renameTree = transform {
  case t: ImportSelectorTree %$\Rightarrow$% 
    mkRenamedImportTree(t, params.newName)
  case s: SymTree %$\Rightarrow$% 
    mkRenamedSymTree(s, params.newName)
  case t: TypeTree %$\Rightarrow$% 
    mkRenamedTypeTree(t, params.newName, prepared.selectedTree.symbol)
}

val rename = topdown(isInTheIndex &> renameTree |> id)

val renamedTrees = occurences flatMap (rename(_))
\end{lstlisting}

The \src{renameTree} transformation handles different kinds of trees but delegates to the \src{TreeFactory} to create the renamed trees. The \src{rename} transformation traverses the trees and renames the trees that are in the index, or keeps the original trees otherwise. This transformation is then applied to all trees returned by the index.

Why do we have to traverse the trees, would it not suffice to call \src{occurences flatMap (renameTree(\_))} directly? No, this will not work for recursive method calls, where the method definition also has a child tree that has to be renamed.

\section{Organize Imports}

It can be debated whether Organize Imports really deserves the label Refactoring, because it does not change the structure of your code; but neither does the Rename refactoring. But Organize Imports is definitely useful, therefore we chose to include it under the refactorings.

During the lifetime of a compilation unit, external dependencies can change and new import statements are added and old ones are removed. Organize imports reorders and simplifies these statements.

\subsection{Features}

Organize imports is the only (implemented) refactoring that does not need a configuration. The current implementation of Organize Imports does these three things:

\begin{description}
  \item[Sort] the statements alphabetically by their full name.
\begin{multicols}{2}
\begin{lstlisting}
import java.lang.{String, Object}
import java.io.File
import collection.mutable.ListBuffer
\end{lstlisting}
\begin{lstlisting}
import collection.mutable.ListBuffer
import java.io.File
import java.lang.{String, Object}
\end{lstlisting}
\end{multicols}

  \item[Collapse] multiple distinct imports from the same package into a single statement:
\begin{multicols}{2}
\begin{lstlisting}
import java.lang.String
import java.lang.Object
\end{lstlisting}
\begin{lstlisting}
import java.lang.{Object, String}

\end{lstlisting}
\end{multicols}

  \item[Simpify] the imports: when a wilcard imports the whole package content, individual import from that package are removed, unless they contain renames:
\begin{multicols}{2}
\begin{lstlisting}
import java.io._
import java.lang._
import java.io.FileSet
import java.lang.{String %$\Rightarrow$% S}
\end{lstlisting}
\needspace{\baselineskip}
\begin{lstlisting}
import java.io._
import java.lang.{String %$\Rightarrow$% S, _}


\end{lstlisting}
\end{multicols}
\end{description}

\figref{figure:organize-screenshot-1} shows a screenshot of the refactoring in action.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{organize_screenshot_1.png}
  \caption{The Organize Imports refactoring: we can see that the imports that were scattered all over the file are now all at the top in alphabetic order. All superfluous statements are getting removed, and imports from the same package are collapsed.}
  \label{figure:organize-screenshot-1}
\end{figure}

\subsection{Limitations}

The current implementation has some limitations compared to its Java counterpart. The refactoring does not do any dependency analysis, imports that are missing are not added, and unneeded imports are not being removed by Organize Imports. There are more features that could be added in future versions:

\paragraph{Save Action} In Eclipse, actions can be performed automatically when a file is saved. Enabling Organize Imports to automatically organize the imports might be useful.

\paragraph{Introduce Import} In Scala, just as in Java, members from other packages do not have to be imported, they can also be used with their fully qualified name. Organize Imports could be extended to replace these fully qualified names with an import statement. 

\paragraph{Expand Wilcards} Once the refactoring does analyze the actually needed dependencies of the compilation unit, the refactoring might also replace all wildcard imports with just the necessary imports. This would also match the JDT's current behaviour.

\paragraph{Shorten Import Paths} In contrast to Java, packages in Scala can be nested (see Appendix~\vref{section:package-nesting}). Organize Imports could take advantage of this and shorten the imported names. For example, the following import on the left could be simplified to the one on the right:

\begin{multicols}{2}
\begin{lstlisting}
package scala.tools.refactoring
package common

import scala.tools.refactoring.analysis.Index
\end{lstlisting}
\needspace{\baselineskip}
\begin{lstlisting}
package scala.tools.refactoring
package common

import analysis.Index
\end{lstlisting}
\end{multicols}


\section{Extract Local}

Extract Local Variable, also known as \textit{Introduce Explaining Variable}, should according to Fowler \cite{FowlerRefactoring} be used whenever ``you have a complicated expression''; and the proposed fix is to 

\begin{quotation}
put the result of the expression, or parts of the expression, in a temporary variable with a name that explains the purpose.
\end{quotation}

In Scala, another reason why one would want to introduce new local variables is because existing Java debuggers are easier to use when one can step over single lines and examine the resulting values.

\subsection{Features}

From a selected expression, the Extract Local refactoring will create a new value in the closest scope and replace the selected expression with a reference to that value. Just as the rename refactoring in a local scope, Extract Local also uses Eclipse's linked mode to avoid distracting the user with dialoges (see \figref{figure:extract-local-screenshot-1} for a screenshot).

\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{extract_local_screenshot_1.png}
  \caption{The Extract Local refactoring also uses the linked mode, making extracting a local variable much faster than with a wizard.}
  \label{figure:extract-local-screenshot-1}
\end{figure}


The following listings show a few exampples of the refactoring, on the left is the original code with the selection in blue, and on the right is the refactored code (line breaks were added by the author).


\begin{multicols}{2}
\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  val props = System.getProperties
  


  if(%\bluebox{props.get("os.name") == "Linux"}%) {
    println("We're on Linux!")
  } else
    println("We're not on Linux!")
}
\end{lstlisting}
\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  val props = System.getProperties
  val %\bluebox{isLinux}% = 
    props.get("os.name") == "Linux"
  
  if(%\bluebox{isLinux}%) {
    println("We're on Linux!")
  } else
    println("We're not on Linux!")
}
\end{lstlisting}
\end{multicols}

\begin{multicols}{2}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {

  println(%\bluebox{"We're on Linux!"}%)
} else
  println("We're not on Linux!")
\end{lstlisting}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {
  val %\bluebox{msg}% = "We're on Linux!"
  println(%\bluebox{msg}%)
} else
  println("We're not on Linux!")
\end{lstlisting}
\end{multicols}

A more interesting examples shows what happens if there are no curly braces around the scope:

\begin{multicols}{2}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {
  println("We're on Linux!")
} else

  println(%\bluebox{"We're not on Linux!"}%)

\end{lstlisting}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {
  println("We're on Linux!")
} else {
  val %\bluebox{msg}% = "We're not on Linux!"
  println(%\bluebox{msg}%)
}
\end{lstlisting}
\end{multicols}

We can extract all kinds of expressions -- for example, a part of a chain of expressions:

\begin{multicols}{2}
\begin{lstlisting}
val l = List(1,2,3)

%\bluebox{l filter (\_ \% 2 == 0)}% mkString ", "
\end{lstlisting}
\begin{lstlisting}
val l = List(1,2,3) 
val %\bluebox{filtered}% = l filter (_ %\%% 2 == 0)
%\bluebox{filtered}% mkString ", "
\end{lstlisting}
\end{multicols}

In the examples so far, we have only extracted expressions that resulted in a non-function value. Extract Local also lets you extract a method, which is turned into a partially applied function:

\begin{multicols}{2}
\begin{lstlisting}
val l = List(1,2,3)
%\bluebox{l filter}% (_ %\%% 2 == 0) mkString ", "

\end{lstlisting}
\begin{lstlisting}
val l = List(1,2,3) 
val %\bluebox{filterList}% = l filter _
%\bluebox{filterList}%(_ %\%% 2 == 0) mkString ", "
\end{lstlisting}
\end{multicols}

In the last example, we show how the extraction behaves inside single-expression statements:

\begin{multicols}{2}
\begin{lstlisting}
val l = List(1,2,3)
l filter (i %$\Rightarrow$% %\bluebox{i \% 2}% == 0) mkString ", "



\end{lstlisting}
\begin{lstlisting}
val l = List(1,2,3) 
l filter (i %$\Rightarrow$% {
  val %\bluebox{x}% = i %\%% 2 
  %\bluebox{x}%== 0
}) mkString ", "
\end{lstlisting}
\end{multicols}

\subsection{Implementation Details}

On the first glance, extracting a local variable seems to be trivial, but when braces are missing, the source generation has to work hard to create them where necessary. An additional difficulty coming from Scala's AST is that \src{Block} trees around a scope are only created when there are multiple statements present. To illustrate this, the following three listings show their respective AST.

\begin{multicols}{3}

\begin{lstlisting}
def m() = 42



\end{lstlisting}
\begin{center}
  $\Downarrow$
\end{center}
\includegraphics[width=0.9\linewidth]{defdef_without_block.pdf}

\columnbreak

\begin{lstlisting}
def m() = { 
  42
}

\end{lstlisting}

\begin{center}
  $\Downarrow$
\end{center}
\includegraphics[width=0.9\linewidth]{defdef_without_block.pdf}

\columnbreak

\begin{lstlisting}
def m() = { 
  42
  42
}
\end{lstlisting}

\begin{center}
  $\Downarrow$
\end{center}
\includegraphics[width=0.9\linewidth]{defdef_with_block.pdf}
\end{multicols}

We can see that the AST in the middle looks just like the first one, even though the literal is surrounded with curly braces. Adding a second statement obviously forces the parser to surround them with a \src{Block}. When we extract a local variable, the refactoring generates a surrounding \src{Block} tree if needed, and the source generators have then to figure out whether they need to print new curly braces.

The Extract Local transformation is implemented as follows:

\begin{lstlisting}
val findInsertionPoint = predicate((t: Tree) %$\Rightarrow$% t == insertionPoint)

def replaceTree(from: Tree, to: Tree) = 
  topdown(matchingChildren(predicate((t: Tree) %$\Rightarrow$% t == from) &> constant(to)))

val insertNewVal = transform {

  case t @ CaseDef(_, _, NoBlock(body)) %$\Rightarrow$%
    t copy (body = mkBlock(newVal :: body :: Nil)) replaces t
    
  case t @ Try(NoBlock(block), _, _) %$\Rightarrow$%
    t copy (block = mkBlock(newVal :: block :: Nil)) replaces t
    
  case t @ DefDef(_, _, _, _, _, NoBlock(rhs)) %$\Rightarrow$%
    t copy (rhs = mkBlock(newVal :: rhs :: Nil)) replaces t
    
  %\ldots%
}

val extractLocal = 
  topdown(
    matchingChildren(
      findInsertionPoint &> 
      replaceTree(selectedExpression, extractedValueReference) &>
      insertNewVal))
\end{lstlisting}

\subsection{Limitations}

Curly braces are not always placed ideally -- for example, the refactoring generates code like 

\begin{lstlisting}
(i %$\Rightarrow$% {
  %\ldots%
})
\end{lstlisting}

when it could just generate the code in the simpler form:

\begin{lstlisting}
{i %$\Rightarrow$%
  %\ldots%
}
\end{lstlisting}

\section{Extract Method}

Also among the most used refactorings by Java programmers is Extract Method. Extract Method is another key refactoring in making your code more readable: if you have some code that can be grouped together, turn it into a method, and give it a meaningful name. The refactoring takes care of passing and returning the necessary parameters.

Martin Fowler once called Extract Method the Refactoring's Rubicon \cite{FowlerRubicon}: 

\begin{quotation}
if you can do Extract Method, it probably means you can go on more refactorings [because it] requires some serious work. You have to analyze the method, find any temporary variables, then figure out what to do with them.
\end{quotation} 

\subsection{Features}

There exist several variations of the refactoring depending on how the selected code interacts with surrounding local variables. In the case where no local variables are used, the refactoring is trivial, we can just move the code into its own method and insert a call at the origin. 

When local variables are uses, they need to be passed into the extracted method; the problematic case arises when local variables are re-assigned or declared inside and used outside of the extracted code. In this case, the respective variable has to be returned from the created method and the call to the created method becomes an assignment to the variable. In Java, this scheme works as long as no more than one variable requires such special treatment. In Scala, we are also restricted by a single return value, but in contrast to Java, Scala has tuples and syntactic sugar for tuple creation and deconstruction, as shown in \figref{figure:tuple-deconstruction}. This allows us to perform the refactoring in Scala where it would not (easily) be possible with similar code in Java.

\begin{figure}
\begin{lstlisting}
def parse(source: String): (Int, String) = {
  %\ldots%
  (intResult, restSource)
}

val (parsedInt, restSource) = parse("5$")
\end{lstlisting}

\caption{An example of Scala tuples. The function \src{parseInt} has the type $String => (Int, String)$ (which is syntactic sugar for $String => Tuple2[Int, String]$). Line~3 shows how such a tuple can be returned; and the last line how it is deconstructed into the two variables \src{parsedInt} and \src{restSource}.}
\label{figure:tuple-deconstruction}
\end{figure}

Scala has other features like first class functions that allow variations of the refactoring, as described in \cite{ScalaRefactoring}. One more thing to mention is the choice of method placement: Scala allows methods to be defined inside other methods, which could also be an option for a Extract Method refactoring implementation.

\subsection{Implementation Details}

Extracting a method is done in several smaller steps:

\begin{description}
  \item[Create the Method] we want to extract. This includes determining all the inbound and outbound dependencies to construct the method signature.
  \item[Replace Extracted Statements] with a call to the newly created method. If the method returns values, we have to assign them to new local values.
  \item[Insert the Method] somewhere in the surrounding class body.
\end{description}

The transformations that are used for Extract Method have already been described in Section~\vref{subsection:tree-transformations}. A screenshot of the refactoring can be seen in \figref{figure:extract-method-screenshot-1}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{extract_method_screenshot_1.png}
  \caption{The Extract Method refactoring: starting with a text selection, the user has to provide a name for the extracted method. The proposed changes are displayed to the user and can then be applied.}
  \label{figure:extract-method-screenshot-1}
\end{figure}

\subsection{Examples}

To start, let us extract a statement that uses local variables and defines a variable that is used later in the program:

\begin{lstlisting}
def main(args: Array[String]) {
  println("Hello World!")
  //create a message:
   %\bluebox{val msg = args mkString ", "}%
  println(msg)
}
\end{lstlisting}

Applying the Extract Method refactoring results in a new method that takes an array as parameter and returns the created string.

\begin{lstlisting}
def main(args: Array[String]) {
  println("Hello World!")
  val msg = makeString(args)
  println(msg)
}
private def makeString(args: Array[String]): String = {
  //create a message:
  val msg = args mkString ", "
  msg
}
\end{lstlisting}

\subsubsection{Returning Multiple Values}

Using tuples to return values, we can return multiple values from an extracted method. The next two listings show an example:

\begin{lstlisting}    
def main(args: Array[String]) {
  val start =  0
  %\bluebox{val end   = 10}%
  %\bluebox{val sum = start to end reduceLeft ((x, y) => x + y)}%
  println("The sum from %\%%d to %\%%d is %\%%d".format(start, end, sum))
}
\end{lstlisting}

\begin{lstlisting}        
def main(args: Array[String]) {
  val start =  0
  val (end, sum) = calculateSum(start)
  println("The sum from %\%%d to %\%%d is %\%%d".format(start, end, sum))
}
private def calculateSum(start: Int): (Int, Int) = {
  val end   = 10
  val sum = start to end reduceLeft ((x, y) => x + y)
  (end, sum)
}
\end{lstlisting}

\subsubsection{Higher Order Functions}

Extract Method can also create a higher order function, as shown below:

\begin{lstlisting}  
def main() {
  
  val sumList: Seq[Int] => Int = _ reduceLeft (_+_)
  val prodList: Seq[Int] => Int = _ reduceLeft (_*_)
  
  val values = 1 to 10 toList
  
  %\bluebox{val     sum = sumList(values)   // the sum}%
  %\bluebox{val product = prodList(values)}%  // the product

  println("The sum from 1 to 10 is "+ sum +"; the product is "+ product)
}
\end{lstlisting}

We can now extract the calculation of the \src{sum} and the \src{product} values. Both values are returned because they are used later in the print statement (line breaks were added manually):

\begin{lstlisting}
def main() {
  
  val sumList: Seq[Int] => Int = _ reduceLeft (_+_)
  val prodList: Seq[Int] => Int = _ reduceLeft (_*_)
  
  val values = 1 to 10 toList
  val (sum, product) = sumAndProd(sumList, prodList, values)

  println("The sum from 1 to 10 is "+ sum +"; the product is "+ product)
}
private def sumAndProd(sumList: (Seq[Int]) => Int, 
                        prodList: (Seq[Int]) => Int, 
                        values: List[Int]): (Int, Int) = {
  val     sum = sumList(values)   // the sum
  val product = prodList(values)  // the product
  (sum, product)
}
\end{lstlisting}

\subsubsection{Arbitrary Expressions}

In our examples so far, we have only extracted statements from blocks. But we can also extract single expressions from within other expressions. The following example extracts the condition of an if-expression:

\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  
  if(%\bluebox{System.getProperties.get("os.name") == "Linux"}%) {
    println("We're on Linux!")
  }
}
\end{lstlisting}

\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  
  if(isLinux) {
    println("We're on Linux!")
  }
}
private def isLinux: Boolean = {
  System.getProperties.get("os.name") == "Linux"
}
\end{lstlisting}

\subsection{Limitations}

\begin{figure}
  \centering
  \includegraphics[width=0.6\linewidth]{extract_method_java_screenshot_1.png}
  \caption{Eclipse JDT's Extract Method Refactoring can be highly customized.}
  \label{figure:extract-method-java-screenshot-1}
\end{figure}


Compared to Eclipse's Extract Method for Java (see \figref{figure:extract-method-java-screenshot-1}), our version offers far less features -- for example, one cannot reorder the parameters, nor rename them. Allowing the user to choose where the extracted method should be placed also has not been implemented yet, and the visibility of the extracted method is always set to private.

Also, the generated code is not always as simple as it could be. Consider the following example:

\begin{lstlisting}
private def makeString(args: Array[String]): String = {
  //create a message:
  val msg = args mkString ", "
  msg
}
\end{lstlisting}

The local value \src{msg} could be inlined to get this simplified extracted method:

\begin{lstlisting}
private def makeString(args: Array[String]): String = {
  //create a message:
  args mkString ", "

}
\end{lstlisting}

\chapter{Tool Integration} \label{chapter:tool-integration}

In this chapter, we're going to look at how the implemented refactorings can be integrated into other software and how the current integration into the Scala IDE for Eclipse looks like.

\section{Dependencies}

The library depends only on the Scala compiler and libraries, no third party libraries are used. To allow a seamless and performand integration into IDEs, the refactoring implementations do not instantiate their own compiler to parse and typecheck the code. This is typically already done or being done by the IDE and would only lead to duplicate effort and significantly slow down the refactoring.

To access the compilation units, the \src{Refactoring} trait -- from which all implementations inherit -- has an abstract member of a compiler instance:

\begin{lstlisting}
trait Refactoring extends %\ldots% {
  val global: scala.tools.nsc.interactive.Global
   %\ldots% 
}
\end{lstlisting}

So in order to instantiate a refactoring implementation, a reference to the compiler has to be provided. How this is done for the automated tests is described in Chapter~\vref{chapter:testing}.

As explained at the beginning of Chapter~\vref{chapter:implemented-refactorings}, a refactoring is performed in several steps; \figref{figure:refactoring-sequence} shows the interaction between the user, the IDE and the refactoring library. The prepare and perform as well as the required parameters are part of the \src{MutliStageRefactoring} abstract class.

\begin{figure}
  \centering
  \includegraphics[width=0.9\linewidth]{refactoring-sequence.pdf}
  \caption{The simplified (error conditions are not shown) interaction that happens when a refactoring is called.}
  \label{figure:refactoring-sequence}
\end{figure}



First, let us take a look at the package layout of the refactoring library:

\begin{center}
  \includegraphics[width=0.5\linewidth]{package-layout.png}
\end{center}






\chapter{Testing} \label{chapter:testing}

The necessity of automated testing in modern software projects bears no repetition. Especially with a project that is so intrinsically dependent on another component -- the Scala compiler -- and its internals, having a strong suite of integration tests is essential. The following chapter shows how the refactoring integration tests are implemented with the goal to provide a guide for creating new tests.

\section{Compiler}

When the refactoring implementations are used, the IDE or more generally the invoking tool provides access to the compiler. The refactoring themselves do not posses the ability to parse the code. In the tests, we therefore also have to provide a compiler that parses and type-checks our test code.

Because instantiating and initializing the compiler is a rather expensive operation, one compiler instance is shared among all the tests. The \src{CompilerProvider} trait shown below gives us access to this instance and provides functionality to turn a string into a fully typed \src{Tree} instance and to add a file in the form of a string to the compiler:

\begin{lstlisting}
trait CompilerProvider {

  val global = CompilerInstance.compiler
    
  def treeFrom(src: String): global.Tree = %\ldots%
  
  def addToCompiler(name: String, src: String): AbstractFile = %\ldots%
}
\end{lstlisting}

Sharing a compiler instance is not without problems: because all the compilation units end up in the same compiler, this might result in conflicts. But this can easily be avoided by putting the individual test cases into their own package.

\section{Creating a Project Layout}

Now that we have a compiler, we need a way to represent Scala source files and combine them to a something like a project. Thanks to Scala's support for raw strings, we can embed the Scala source code directly in our test cases and do not have to store them in external files or concatenate strings together. So in our test cases we can construct an AST from a string like this:

\begin{lstlisting}
val tree: global.Tree = treeFrom("""
  object Main {
    def main(args: Array[String]) {
    }
  }
""")
\end{lstlisting}

The \src{FileSet} class can be used to represent a Scala test project. It has an implicit conversion (see Appendix \vref{section:implicit-conversions}) method that adds the \src{becomes} method to \src{String} so it can be used as follows:

\begin{lstlisting}
val project = new FileSet {
  """
    Content of this source file.
  """ becomes
  """
    Expected test result for this file.
  """;

  "a second source file" becomes " %\ldots% "
}
\end{lstlisting}

The \src{FileSet} class also contains a method \src{applyRefactoring} that takes a function from \src{FileSet} to \src{List[Change]} which it uses to turn the specified source files into a list of changes. The changes are then applied to the sources and their result compared to the expected results using the standard JUnit asserts.

\section{Implementation}

Taking a look at a test for the \src{Organize Imports} refactoring, the result looks as follows:

\begin{lstlisting}
@Test
def sortImportsByName = new FileSet {
  """
    import scala.collection.mutable.ListBuffer
    import java.lang.Object

    object Main
  """ becomes
  """
    import java.lang.Object
    import scala.collection.mutable.ListBuffer

    object Main
  """
} applyRefactoring %\textbf{organize}%
\end{lstlisting}

The \src{organize} function simply instantiates the concrete refactoring and performs it, returning the list of changes the refactoring generated. Organize Imports is a very simple refactoring because it needs neither a selection from the user nor any other configuration. A test case for the Rename refactoring can be seen in the following listing:

\begin{lstlisting}
@Test
def renameSelfType = new FileSet {
  """
  trait /*(*/T1/*)*/

  trait T3 {
    self: T1 %$\Rightarrow$%

  }""" becomes
  """
  trait /*(*/Trait/*)*/

  trait T3 {
    self: Trait %$\Rightarrow$%

  }"""
} applyRefactoring %\textbf{renameTo}%("Trait")
\end{lstlisting}

The selection is indicated by the two comments \src{/*(*/} and \src{/*)*/}. The comments remain in the source code, this is why we also see them in the expected result. With the help of Scala's multiple argument lists and partial application of functions, the \src{renameTo} function can be implemented like this:

\begin{lstlisting}
def renameTo(name: String)(pro: FileSet): List[Change] = %\ldots%
\end{lstlisting}

%The structure of the test packages follows the main library.

\chapter{Outlook} \label{chapter:outlook}

\section{Accomplishments}

XXX needs some kind of conclusion, we have achieved our goal of having source generation that doesn't need user interaction.

other usages (Richard?)


\section{Acknowledgments}

I would like to thank ..

\section{Future Work}

what is left to do, how can the work be extended

\appendix

\chapter{User Guide} \label{chapter:user-guide}

User guide, also in HTML on the Wiki. Describes the usage of the implemented refactoring along with their shortcomings.

\chapter{Developer How-To} \label{chapter:developer-how-to}

A short introduction by example, for more depth, refer to the main documentation.

\include{9_appendix}

\include{91_scala_ast}

\clearpage
\bib

\end{document}


