\documentclass[10pt,a4paper,oneside]{scrreprt}
\usepackage{mystyle}

\begin{document}

\newcommand{\subtitlename}{Master's Thesis}
\newcommand{\titlename}{Scala Refactoring}

\include{0_front}

\emptypage

\chapter*{Abstract}

\pagenumbering{roman}

This thesis..


\chapter*{Management Summary}

This documentation 

\newpage

\setcounter{tocdepth}{2}

\tableofcontents

\newpage

\pagenumbering{arabic}

\chapter{Introduction} \label{chapter:introduction}

The goal of this thesis is to provide Scala developers with automated refactoring tools. This master's thesis is a continuation of a term project (see \cite{ScalaRefactoring}) at the University of Applied Sciences Rapperswil, Switzerland. 

In this chapter, we will briefly introduce the Refactoring technique and the Scala programming language, as well as explain the goals and motivation of this thesis.

\section{Refactoring}

Refactoring of programs is a well established practice among professional software developers. In his 1992 PhD thesis \cite{OpdykeThesis}, William Opdyke defined refactoring as 

\begin{quotation}
a set of program restructuring operations (refactorings) that support the design, evolution and reuse of object-oriented application frameworks.
\end{quotation}

The breakthrough in industry started in 1999, when Martin Fowler and his colleagues published their popular book \textit{Refactoring: Improving the Design of Existing Code} \cite{FowlerRefactoring}, where refactoring is defined as 

\begin{quotation}
the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure.
\end{quotation} 

Today, refactoring has been absorbed by the programming mainstream, and is usually well integrated into the developer's work-flow and development environment. Developers use refactoring tools to keep their code maintainable by applying refactorings such as Rename to quickly change identifiers. In agile environments, where software is rapidly adapted to handle new requirements, performing refactorings regularly is essential to get reusable code and to keep up with the pace of change.

Refactoring as a technique does not mandate a tool nor depend on a specific programming language.

\section{Scala}

The Scala programming language \cite{ProgrammingScala}, developed by Martin Odersky and his team at EPFL, is a statically typed, compiled language that runs on the Java Virtual Machine (or on .NET alternatively \cite{ScalacNet}) and excels with its unique combination of object-oriented and functional programming concepts. Oderksy also calls Scala a postfunctional language because it has been designed ``to make functional constructs, imperative constructs, and objects all play well together'' \cite{ScalaPostFunctional}. 

One of Scala's strengths is its seamless interoperability with Java on the class level: Scala classes can extend Java classes and vice-versa. Scala also does not ship with a huge standard library but uses existing Java classes where it is sensible.

Scala provides all of Java's object-oriented features but does away with the non-object oriented ones like primitive data types and static class members. Scala also provides code reuse via traits; a kind of interface that may contain implementations.

From functional programming, Scala has absorbed functions as first class values and embraces the idea of immutability with various language constructs. Scala even supports lazy evaluation through by-name parameters and the \src{lazy} modifier for values. A combination from both object-oriented and functional worlds can be seen in Scala's ability to use pattern matching to deconstruct objects while still preserving encapsulation.

These were just a few examples of how Scala differs from other languages such as Java. One last feature worth mentioning is that in Scala, building your own abstractions and control structures is easy, which is the reason why it has been named the ``scalable language''.

\section{Integrated Development Environments}

Many programmers, particularly of mainstream languages such as Java and C\#, use integrated development environments (IDE) to create their software. Especially the IDEs for the Java programming language excel with automated refactoring support; the screen-shots in \figref{figure:ide_refactorings} show two examples. If Scala wants to cater to those programmers and become a viable alternative in enterprises, it needs to offer IDE support that is as comfortable to use and as mature as the existing Java tooling is.

Scala is supported on the three main Java development platforms Eclipse \cite{EclipseScalaIDE}, IntelliJ IDEA \cite{IntelliJScalaIDE}, and NetBeans \cite{NetBeansJScalaIDE}, but with the exception of IntelliJ IDEA -- which offers a few refactorings -- support for automated refactoring does not yet exist. Although a study by Emerson~Murphy-Hill et al. among developers using Eclipse \cite{RefactoringStudy} indicates that many refactorings are not performed with the tool support but by hand, other automated refactorings like Rename, Move and Extract Method are used frequently.

\begin{figure}
 \centering
 \includegraphics[width=0.7\linewidth]{ide_refactorings.png}
 \caption{Automated refactoring in Java IDEs}
 \label{figure:ide_refactorings}
\end{figure}

\section{Thesis Goals}

The goal of this thesis is to support Scala IDEs with automated refactoring support. It aims to provide a comprehensive catalogue of refactorings and the necessary infrastructure to create new refactorings. To maximize the number of IDEs and other tools that can profit from the project, it will provide an IDE independent refactoring library that only depends on the Scala compiler. IDEs can then integrate this library by providing the user interface and interaction.

As most IDEs today are written in Java, integrating a Scala library is no problem. Also, because the majority of Scala IDEs are open source (NetBeans, Eclipse), having a single refactoring library allows their developers to cooperate on an implementation, not fragmenting the already scarce resources any further. As a showcase, this project provides the integration into the Eclipse based Scala IDE \cite{EclipseScalaIDE}.

Writing an automated refactoring is no easy task, several things have to be taken care of: one has to analyze the source code, create an appropriate representation (e.g. abstract or concrete syntax tree) of the program, transform it and turn it back into plain source code. 

The heart of a refactoring is the transformation or manipulation of the program representation; but often -- from our experience with refactoring tools for languages like Ruby \cite{RubyRefactoring}, C++ \cite{CdtOopsla}, and Groovy \cite{GroovyOopsla} -- the developer also has to provide the instructions how these manipulations affect the source code, or how the changes made to the AST are to be translated back into the source code. This makes creating new refactorings unjustifiably more complex and is a high entry barrier for contributors. The Scala refactoring library tries to make creating new refactorings as simple as possible: code generation from the abstract syntax tree is implemented generically and needs no help from the refactoring writer.

Transformations of the program are based on the Scala compiler's own AST, and are written in a functional programming style that makes it possible to assemble complex transformations from simple ones.

To summarize, the Scala Refactoring project provides an IDE independent refactoring library which makes creating new refactorings as simple as possible.

%(Sollte hier noch mehr kommen? Z.B. mehr \"uber die Resultate? Eigentlich m\"ochte ich das im Outlook besprechen, aber vielleicht geh\"ort es auch schon hier hin.)

\section{Contents of This Report}

This document is organized as follows: Chapter~\vref{chapter:refactoring-library} explains the concepts and implementation of the refactoring library. The details of the implemented refactorings are described in Chapter~\vref{chapter:implemented-refactorings}. How these refactorings can be integrated into an IDE or other tool is the topic of Chapter~\vref{chapter:tool-integration}. How the implemented refactorings are tested is explained in Chapter~\vref{chapter:testing}. Chapter~\vref{chapter:outlook} concludes this thesis with a review of the achievements and an outlook on further work.

The appendices contain a user guide to the refactorings in Eclipse (Appendix~\vref{chapter:user-guide}), and a how-to introduction for developers that explains how a new refactoring can be created in Appendix~\vref{chapter:developer-how-to}. The project environment is briefly explained in Appendix~\vref{chapter:project-environment}. Developers that work with Scala's AST might also be interested in Appendix~\vref{chapter:scala-ast}, where the specific trees of the AST are described. Finally, Appendix~\vref{chapter:advanced-scala-features} contains explanations of more advanced Scala features and is referenced where needed in this document.

\section{Target Audience}

We assume that the reader knows some of the basic Scala concepts and is able to read Scala source code. Whenever more advanced or possibly unknown concepts are used, a reference to Appendix~\vref{chapter:advanced-scala-features} is provided.

Developers who want to use the library to transform Scala source code should read Chapter~\vref{chapter:refactoring-library} on the library internals and Appendix~\vref{chapter:scala-ast} to learn more about Scala's AST. 

To integrated the existing refactorings in a new environment, Chapter~\vref{chapter:tool-integration} shows how this can be done with a made up editor and how the integration into the Scala IDE for Eclipse looks like.

For those wishing to implement new refactorings, the how-to in Appendix~\vref{chapter:developer-how-to} and Chapter~\vref{chapter:implemented-refactorings} on the implemented refactorings can serve as a starting point. How the new refactoring can be tested is explained in Chapter~\vref{chapter:testing}.

Users who wish to provide accurate bug reports should take a look at Chapter~\vref{chapter:testing} on testing to learn how a new test that points out a failure can be implemented.

\chapter{Refactoring Library} \label{chapter:refactoring-library}

\input{2_refactoring_library}

\chapter{Implemented Refactorings} \label{chapter:implemented-refactorings}

The previous chapter explained the internals of the Scala Refactoring library; in this chapter, we shall take a look at the refactorings that have so far been implemented on top of the library. 

The three components of the refactoring library -- analysis, transformation, and source generation -- can be used independently from each other, but they also have dependencies expressed through self type annotations (see \vref{section:self-type-annotation}). 

The \src{Refactoring} trait combines the library with their dependencies and can be used as an entry point by library users.

\begin{lstlisting}
trait Refactoring extends 
  Selections with 
  TreeTransformations with 
  SilentTracing with 
  SourceGenerator with 
  PimpedTrees {
  %\ldots%
}
\end{lstlisting}

Performing a refactoring is not a single-step process: when the user invokes a refactoring, the first step is to check whether the refactoring can be applied -- for example, to perform a renaming, a name has to be selected. We call this the \textit{prepare} step. This step usually has a result, which is used in a configuration dialog to parameterize the refactoring. In our renaming example, this is the new name. Using the information from the preparation step and the configured parameters, the refactoring can then be \textit{performed}. This yields either a list of changes to be applied or it can also fail. See  \figref{figure:refactoring-sequence} for a visualization.

These steps are represented by the abstract class \src{MultiStageRefactoring}, which is subclassed by all concrete refactoring implementations:
\needspace{15\baselineskip}
\begin{lstlisting}
abstract class MultiStageRefactoring extends Refactoring {
  
  type PreparationResult
  
  case class PreparationError(cause: String)

  def prepare(s: Selection): Either[PreparationError, PreparationResult]

  type RefactoringParameters
  
  case class RefactoringError(cause: String)
  
  def perform(selection: Selection, prepared: PreparationResult, params: RefactoringParameters)
    : Either[RefactoringError, List[Change]]
}
\end{lstlisting}

The reason why the selection and the preparation results need to be passed to \src{perform} is to keep it stateless. This makes it much easier for an IDE to let the user go backwards and forwards in its wizard, testing different configurations.

The remainder of this chapter introduces each refactoring and explains the current implementation for the Eclipse Scala IDE with examples. 

\section{Rename}

Renaming is one of the most used refactorings among Eclipse using Java programmers (see \cite{RefactoringStudy}, \cite{RefactoringInEclipse}). Choosing good names is a very basic and yet important task for a programmer if he wants to write readable code. During the evolution of a program, the roles of the classes, methods and variables change. Having an automated refactoring for renaming considerably reduces the cost of keeping these names in sync with their functionality.

\subsection{Features}

This implementation supports renaming of all identifiers that occur in the program -- for example, local values and variables, method definitions and parameters, class fields, variable bindings in pattern matches, classes, objects, traits, packages, and types parameters.

The IDE implementation distinguishes between two different modes: inline renaming as shown in \figref{figure:rename-screenshot-1} and the traditional dialog based implementation in \figref{figure:rename-screenshot-2}. Inline renaming is implemented using Eclipse's linked mode user interface \cite{LinkedUI}.

\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{rename_screenshot_1.png}
  \caption{The Rename refactoring in the inline mode: the selected name along with all references can be renamed without the need of a wizard and without previewing the changes.}
  \label{figure:rename-screenshot-1}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{rename_screenshot_2.png}
  \caption{A classical Rename refactoring: All occurences of the selected name are changed across all files in the project.}
  \label{figure:rename-screenshot-2}
\end{figure}

Inline renaming is automatically chosen if the identifier that is renamed has only a local scope -- for example, a local variable. All names that can potentially be access from other compilation units in the program are renamed with the wizard and show a change set at the end.

\subsection{Implementation Details}

From the refactoring developer's point of view, the Rename refactoring is a quite different beast than other refactorings. Because renaming does not change the shape of the AST at all, the transformations and source generation steps are trivial. On the other hand, having an accurate index is crucial; the inline rename refactoring uses only the index to find the locations of the names and does not use the source generator or tree transformations.

The implementation for the non-inline mode looks as follows:

\begin{lstlisting}
val occurences = index.occurences(prepared.selectedTree.symbol) 
    
val isInTheIndex = filter {
  case t: Tree %$\Rightarrow$% occurences contains t 
}

val renameTree = transform {
  case t: ImportSelectorTree %$\Rightarrow$% 
    mkRenamedImportTree(t, params.newName)
  case s: SymTree %$\Rightarrow$% 
    mkRenamedSymTree(s, params.newName)
  case t: TypeTree %$\Rightarrow$% 
    mkRenamedTypeTree(t, params.newName, prepared.selectedTree.symbol)
}

val rename = topdown(isInTheIndex &> renameTree |> id)

val renamedTrees = occurences flatMap (rename(_))
\end{lstlisting}

The \src{renameTree} transformation handles different kinds of trees but delegates to the \src{TreeFactory} to create the renamed trees. The \src{rename} transformation traverses the trees and renames the trees that are in the index, or keeps the original trees otherwise. This transformation is then applied to all trees returned by the index.

Why do we have to traverse the trees, would it not suffice to call \src{occurences flatMap (renameTree(\_))} directly? No, this will not work for recursive method calls, where the method definition also has a child tree that has to be renamed.

\subsection{Limitations}

There is currently one limitation with the Rename refactoring: named parameters will not be renamed because they are not represented in the AST.

\section{Organize Imports}

It can be debated whether Organize Imports really deserves the label Refactoring, because it does not change the structure of your code; but neither does the Rename refactoring. But Organize Imports is definitely useful, therefore we chose to include it under the refactorings.

During the lifetime of a compilation unit, external dependencies can change and new import statements are added and old ones are removed. Organize imports reorders and simplifies these statements.

\subsection{Features}

Organize imports is the only implemented refactoring that does not need a configuration. The current implementation of Organize Imports does these three things:

\begin{description}
  \item[Sort] the statements alphabetically by their full name.
\begin{multicols}{2}
\begin{lstlisting}
import java.lang.{String, Object}
import java.io.File
import collection.mutable.ListBuffer
\end{lstlisting}
\begin{lstlisting}
import collection.mutable.ListBuffer
import java.io.File
import java.lang.{String, Object}
\end{lstlisting}
\end{multicols}

  \item[Collapse] multiple distinct imports from the same package into a single statement:
\begin{multicols}{2}
\begin{lstlisting}
import java.lang.String
import java.lang.Object
\end{lstlisting}
\begin{lstlisting}
import java.lang.{Object, String}

\end{lstlisting}
\end{multicols}

  \item[Simpify] the imports: when a wilcard imports the whole package content, individual import from that package are removed, unless they contain renames:
\begin{multicols}{2}
\begin{lstlisting}
import java.io._
import java.lang._
import java.io.FileSet
import java.lang.{String %$\Rightarrow$% S}
\end{lstlisting}
\needspace{\baselineskip}
\begin{lstlisting}
import java.io._
import java.lang.{String %$\Rightarrow$% S, _}


\end{lstlisting}
\end{multicols}
\end{description}

\figref{figure:organize-screenshot-1} shows a screenshot of the refactoring in action.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{organize_screenshot_1.png}
  \caption{The Organize Imports refactoring: we can see that the imports that were scattered all over the file are now all at the top in alphabetic order. All superfluous statements are getting removed, and imports from the same package are collapsed.}
  \label{figure:organize-screenshot-1}
\end{figure}

\subsection{Limitations}

The current implementation has some limitations compared to its Java counterpart. The refactoring does not do any dependency analysis, imports that are missing are not added, and unneeded imports are not being removed by Organize Imports. There are more features that could be added in future versions:

\paragraph{Save Action} In Eclipse, actions can be performed automatically when a file is saved. Enabling Organize Imports to automatically organize the imports might be useful.

\paragraph{Introduce Import} In Scala, just as in Java, members from other packages do not have to be imported, they can also be used with their fully qualified name. Organize Imports could be extended to replace these fully qualified names with an import statement. 

\paragraph{Expand Wilcards} Once the refactoring does analyze the actually needed dependencies of the compilation unit, the refactoring might also replace all wildcard imports with just the necessary imports. This would also match the JDT's current behaviour.

\paragraph{Shorten Import Paths} In contrast to Java, packages in Scala can be nested (see Appendix~\vref{section:package-nesting}). Organize Imports could take advantage of this and shorten the imported names. For example, the following import on the left could be simplified to the one on the right:

\begin{multicols}{2}
\begin{lstlisting}
package scala.tools.refactoring
package common

import scala.tools.refactoring.analysis.Index
\end{lstlisting}
\needspace{\baselineskip}
\begin{lstlisting}
package scala.tools.refactoring
package common

import analysis.Index
\end{lstlisting}
\end{multicols}

\section{Extract Local}

Extract Local Variable, also known as \textit{Introduce Explaining Variable}, should according to Fowler \cite{FowlerRefactoring} be used whenever ``you have a complicated expression''; and the proposed fix is to 

\begin{quotation}
put the result of the expression, or parts of the expression, in a temporary variable with a name that explains the purpose.
\end{quotation}

In Scala, another reason why one would want to introduce new local variables is because existing Java debuggers are easier to use when one can step over single lines and examine the resulting values.

\subsection{Features}

From a selected expression, the Extract Local refactoring will create a new value in the closest scope and replace the selected expression with a reference to that value. Just as the rename refactoring in a local scope, Extract Local also uses Eclipse's linked mode to avoid distracting the user with dialoges (see \figref{figure:extract-local-screenshot-1} for a screenshot).

\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{extract_local_screenshot_1.png}
  \caption{The Extract Local refactoring also uses the linked mode, making extracting a local variable much faster than with a wizard.}
  \label{figure:extract-local-screenshot-1}
\end{figure}


The following listings show a few exampples of the refactoring, on the left is the original code with the selection in blue, and on the right is the refactored code (line breaks were added by the author).

\begin{multicols}{2}
\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  val props = System.getProperties
  


  if(%\bluebox{props.get("os.name") == "Linux"}%) {
    println("We're on Linux!")
  } else
    println("We're not on Linux!")
}
\end{lstlisting}
\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  val props = System.getProperties
  val %\bluebox{isLinux}% = 
    props.get("os.name") == "Linux"
  
  if(%\bluebox{isLinux}%) {
    println("We're on Linux!")
  } else
    println("We're not on Linux!")
}
\end{lstlisting}
\end{multicols}

\needspace{5\baselineskip}
\begin{multicols}{2}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {

  println(%\bluebox{"We're on Linux!"}%)
} else
  println("We're not on Linux!")
\end{lstlisting}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {
  val %\bluebox{msg}% = "We're on Linux!"
  println(%\bluebox{msg}%)
} else
  println("We're not on Linux!")
\end{lstlisting}
\end{multicols}

A more interesting examples shows what happens if there are no curly braces around the scope:

\begin{multicols}{2}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {
  println("We're on Linux!")
} else

  println(%\bluebox{"We're not on Linux!"}%)

\end{lstlisting}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {
  println("We're on Linux!")
} else {
  val %\bluebox{msg}% = "We're not on Linux!"
  println(%\bluebox{msg}%)
}
\end{lstlisting}
\end{multicols}

We can extract all kinds of expressions -- for example, a part of a chain of expressions:

\begin{multicols}{2}
\begin{lstlisting}
val l = List(1,2,3)

%\bluebox{l filter (\_ \% 2 == 0)}% mkString ", "
\end{lstlisting}
\begin{lstlisting}
val l = List(1,2,3) 
val %\bluebox{filtered}% = l filter (_ %\%% 2 == 0)
%\bluebox{filtered}% mkString ", "
\end{lstlisting}
\end{multicols}

In the examples so far, we have only extracted expressions that resulted in a non-function value. Extract Local also lets you extract a method, which is turned into a partially applied function:

\begin{multicols}{2}
\begin{lstlisting}
val l = List(1,2,3)
%\bluebox{l filter}% (_ %\%% 2 == 0) mkString ", "

\end{lstlisting}
\begin{lstlisting}
val l = List(1,2,3) 
val %\bluebox{filterList}% = l filter _
%\bluebox{filterList}%(_ %\%% 2 == 0) mkString ", "
\end{lstlisting}
\end{multicols}

In the last example, we show how the extraction behaves inside single-expression statements:

\begin{multicols}{2}
\begin{lstlisting}
val l = List(1,2,3)
l filter (i %$\Rightarrow$% %\bluebox{i \% 2}% == 0) mkString ", "



\end{lstlisting}
\begin{lstlisting}
val l = List(1,2,3) 
l filter (i %$\Rightarrow$% {
  val %\bluebox{x}% = i %\%% 2 
  %\bluebox{x}%== 0
}) mkString ", "
\end{lstlisting}
\end{multicols}

\subsection{Implementation Details}

On the first glance, extracting a local variable seems to be trivial, but when braces are missing, the source generation has to work hard to create them where necessary. An additional difficulty coming from Scala's AST is that \src{Block} trees around a scope are only created when there are multiple statements present. To illustrate this, the following three listings show their respective AST.

\begin{multicols}{3}

\begin{lstlisting}
def m() = 42



\end{lstlisting}
\begin{center}
  $\Downarrow$
\end{center}
\includegraphics[width=0.9\linewidth]{defdef_without_block.pdf}

\columnbreak

\begin{lstlisting}
def m() = { 
  42
}

\end{lstlisting}

\begin{center}
  $\Downarrow$
\end{center}
\includegraphics[width=0.9\linewidth]{defdef_without_block.pdf}

\columnbreak

\begin{lstlisting}
def m() = { 
  42
  42
}
\end{lstlisting}

\begin{center}
  $\Downarrow$
\end{center}
\includegraphics[width=0.9\linewidth]{defdef_with_block.pdf}
\end{multicols}

We can see that the AST in the middle looks just like the first one, even though the literal is surrounded with curly braces. Adding a second statement obviously forces the parser to surround them with a \src{Block}. When we extract a local variable, the refactoring generates a surrounding \src{Block} tree if needed, and the source generators have then to figure out whether they need to print new curly braces.
\newpage
The Extract Local transformation is implemented as follows:

\begin{lstlisting}
val findInsertionPoint = predicate((t: Tree) %$\Rightarrow$% t == insertionPoint)

def replaceTree(from: Tree, to: Tree) = 
  topdown(matchingChildren(predicate((t: Tree) %$\Rightarrow$% t == from) &> constant(to)))

val insertNewVal = transform {

  case t @ CaseDef(_, _, NoBlock(body)) %$\Rightarrow$%
    t copy (body = mkBlock(newVal :: body :: Nil)) replaces t
    
  case t @ Try(NoBlock(block), _, _) %$\Rightarrow$%
    t copy (block = mkBlock(newVal :: block :: Nil)) replaces t
    
  case t @ DefDef(_, _, _, _, _, NoBlock(rhs)) %$\Rightarrow$%
    t copy (rhs = mkBlock(newVal :: rhs :: Nil)) replaces t
    
  %\ldots%
}

val extractLocal = 
  topdown(
    matchingChildren(
      findInsertionPoint &> 
      replaceTree(selectedExpression, extractedValueReference) &>
      insertNewVal))
\end{lstlisting}

\subsection{Limitations}

Curly braces are not always placed ideally -- for example, the refactoring generates code like 

\begin{lstlisting}
(i %$\Rightarrow$% {
  %\ldots%
})
\end{lstlisting}

when it could just generate the code in the simpler form:

\begin{lstlisting}
{i %$\Rightarrow$%
  %\ldots%
}
\end{lstlisting}

\section{Extract Method}

Also among the most used refactorings by Java programmers is Extract Method. Extract Method is another key refactoring in making code more readable: if there is some code that can be grouped together, turn it into a method, and give it a meaningful name. The refactoring takes care of passing and returning the necessary parameters.

Martin Fowler once called Extract Method the Refactoring's Rubicon \cite{FowlerRubicon}: 

\begin{quotation}
if you can do Extract Method, it probably means you can go on more refactorings [because it] requires some serious work. You have to analyze the method, find any temporary variables, then figure out what to do with them.
\end{quotation} 

\subsection{Features}

There exist several variations of the refactoring depending on how the selected code interacts with surrounding local variables. In the case where no local variables are used, the refactoring is trivial, we can just move the code into its own method and insert a call at the origin. 

When local variables are used, they need to be passed into the extracted method; the problematic case arises when local variables are re-assigned or declared inside and used outside of the extracted code. In this case, the respective variable has to be returned from the created method and the call to the created method becomes an assignment to the variable. 

In Java, this scheme works as long as no more than one variable requires such special treatment. In Scala, we are also restricted by a single return value, but in contrast to Java, Scala has tuples and syntactic sugar for tuple creation and deconstruction, as shown in \figref{figure:tuple-deconstruction}. This allows us to perform the refactoring in Scala where it would not (easily) be possible with similar code in Java.

\begin{figure}
\begin{lstlisting}
def parse(source: String): (Int, String) = {
  %\ldots%
  (intResult, restSource)
}

val (parsedInt, restSource) = parse("5$")
\end{lstlisting}

\caption{An example of Scala tuples. The function \src{parseInt} has the type $String => (Int, String)$ (which is syntactic sugar for $String => Tuple2[Int, String]$). Line~3 shows how such a tuple can be returned; and the last line how it is deconstructed into the two variables \src{parsedInt} and \src{restSource}.}
\label{figure:tuple-deconstruction}
\end{figure}

Scala has other features like first class functions that allow variations of the refactoring, as described in \cite{ScalaRefactoring}. One more thing to mention is the choice of method placement: Scala allows methods to be defined inside other methods, which could also be an option for an Extract Method refactoring implementation.

\subsection{Implementation Details}

Extracting a method is done in several smaller steps:

\begin{description}
  \item[Create the Method] we want to extract. This includes determining all the inbound and outbound dependencies to construct the method signature.
  \item[Replace Extracted Statements] with a call to the newly created method. If the method returns values, we have to assign them to new local values.
  \item[Insert the Method] somewhere in the surrounding class body.
\end{description}

The transformations that are used for Extract Method have already been described in Section~\vref{subsection:tree-transformations}. A screenshot of the refactoring can be seen in \figref{figure:extract-method-screenshot-1}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{extract_method_screenshot_1.png}
  \caption{The Extract Method refactoring: starting with a text selection, the user has to provide a name for the extracted method. The proposed changes are displayed to the user and can then be applied.}
  \label{figure:extract-method-screenshot-1}
\end{figure}

\subsection{Examples}

To start, let us extract a statement that uses local variables and defines a variable that is used later in the program:

\begin{lstlisting}
def main(args: Array[String]) {
  println("Hello World!")
  //create a message:
   %\bluebox{val msg = args mkString ", "}%
  println(msg)
}
\end{lstlisting}

Applying the Extract Method refactoring results in a new method that takes an array as parameter and returns the created string.

\begin{lstlisting}
def main(args: Array[String]) {
  println("Hello World!")
  val msg = makeString(args)
  println(msg)
}
private def makeString(args: Array[String]): String = {
  //create a message:
  val msg = args mkString ", "
  msg
}
\end{lstlisting}

\subsubsection{Returning Multiple Values}

Using tuples to return values, we can return multiple values from an extracted method. The next two listings show an example:

\begin{lstlisting}    
def main(args: Array[String]) {
  val start =  0
  %\bluebox{val end   = 10}%
  %\bluebox{val sum = start to end reduceLeft ((x, y) => x + y)}%
  println("The sum from %\%%d to %\%%d is %\%%d".format(start, end, sum))
}
\end{lstlisting}

\begin{lstlisting}        
def main(args: Array[String]) {
  val start =  0
  val (end, sum) = calculateSum(start)
  println("The sum from %\%%d to %\%%d is %\%%d".format(start, end, sum))
}
private def calculateSum(start: Int): (Int, Int) = {
  val end   = 10
  val sum = start to end reduceLeft ((x, y) => x + y)
  (end, sum)
}
\end{lstlisting}

\subsubsection{Higher Order Functions}

Extract Method can also create a higher order function, as shown below:

\begin{lstlisting}  
def main() {
  
  val sumList: Seq[Int] => Int = _ reduceLeft (_+_)
  val prodList: Seq[Int] => Int = _ reduceLeft (_*_)
  
  val values = 1 to 10 toList
  
  %\bluebox{val     sum = sumList(values)   // the sum}%
  %\bluebox{val product = prodList(values)}%  // the product

  println("The sum from 1 to 10 is "+ sum +"; the product is "+ product)
}
\end{lstlisting}

We can now extract the calculation of the \src{sum} and the \src{product} values. Both values are returned because they are used later in the print statement (line breaks were added manually):

\begin{lstlisting}
def main() {
  
  val sumList: Seq[Int] => Int = _ reduceLeft (_+_)
  val prodList: Seq[Int] => Int = _ reduceLeft (_*_)
  
  val values = 1 to 10 toList
  val (sum, product) = sumAndProd(sumList, prodList, values)

  println("The sum from 1 to 10 is "+ sum +"; the product is "+ product)
}
private def sumAndProd(sumList: (Seq[Int]) => Int, 
                        prodList: (Seq[Int]) => Int, 
                        values: List[Int]): (Int, Int) = {
  val     sum = sumList(values)   // the sum
  val product = prodList(values)  // the product
  (sum, product)
}
\end{lstlisting}

\subsubsection{Arbitrary Expressions}

In our examples so far, we have only extracted statements from blocks. But we can also extract single expressions from within other expressions. The following example extracts the condition of an if-expression:

\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  
  if(%\bluebox{System.getProperties.get("os.name") == "Linux"}%) {
    println("We're on Linux!")
  }
}
\end{lstlisting}
\needspace{11\baselineskip}
\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  
  if(isLinux) {
    println("We're on Linux!")
  }
}
private def isLinux: Boolean = {
  System.getProperties.get("os.name") == "Linux"
}
\end{lstlisting}

\subsection{Limitations}

\begin{figure}
  \centering
  \includegraphics[width=0.6\linewidth]{extract_method_java_screenshot_1.png}
  \caption{Eclipse JDT's Extract Method Refactoring can be highly customized.}
  \label{figure:extract-method-java-screenshot-1}
\end{figure}


Compared to Eclipse's Extract Method for Java (see \figref{figure:extract-method-java-screenshot-1}), our version offers far less features -- for example, one cannot reorder the parameters, nor rename them. Allowing the user to choose where the extracted method should be placed also has not been implemented yet, and the visibility of the extracted method is always set to private.

Also, the generated code is not always as simple as it could be. Consider the following example:

\needspace{5\baselineskip}
\begin{lstlisting}
private def makeString(args: Array[String]): String = {
  //create a message:
  val msg = args mkString ", "
  msg
}
\end{lstlisting}

The local value \src{msg} could be inlined to get this simplified extracted method:

\begin{lstlisting}
private def makeString(args: Array[String]): String = {
  //create a message:
  args mkString ", "

}
\end{lstlisting}

\chapter{Tool Integration} \label{chapter:tool-integration}

In this chapter, we're going to look at how the implemented refactorings can be integrated into other software and how the current integration into the Scala IDE for Eclipse looks like.

\section{Dependencies}

The refactoring library depends only on the Scala compiler -- no third party libraries are used. But it also does not contain any user interface; for a seamless integration, this needs to be implemented by the integrating tool.

For a performant integration into IDEs, the refactoring implementations do not instantiate their own compiler to parse and typecheck the code. This is typically already being done by the IDE and would only lead to duplicate effort and significantly slow down the refactoring process.

To access the compilation units of a project, the \src{Refactoring} trait -- from which all implementations inherit -- has an abstract member of a compiler instance:

\begin{lstlisting}
trait Refactoring extends %\ldots% {
  val global: scala.tools.nsc.interactive.Global
  %\ldots% 
}
\end{lstlisting}

So in order to instantiate a refactoring implementation, a reference to the compiler has to be provided. How this is done for the automated tests is described in Chapter~\vref{chapter:testing}.

As explained at the beginning of Chapter~\vref{chapter:implemented-refactorings}, a refactoring is performed in several steps; \figref{figure:refactoring-sequence} visualizes the interaction between the user, the IDE and the refactoring library. The prepare and perform methods as well as the required parameters are part of the \src{MutliStageRefactoring} abstract class (see \figref{figure:package-layout}).

\begin{figure}
  \centering
  \includegraphics[width=0.9\linewidth]{refactoring-sequence.pdf}
  \caption{The simplified (error conditions are not shown) interaction that happens when a refactoring is called.}
  \label{figure:refactoring-sequence}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{package-layout.png}
  \caption{The package layout of the library, showing the base classes and the implemented refactorings.}
  \label{figure:package-layout}
\end{figure}

\section{Integrating the Library}

\begin{figure}
  \centering
  \includegraphics[width=0.7\linewidth]{refactoring-editor.png}
  \caption{The Refactoring Editor: A simple Swing editor that can open files and invoke the refactorings.}
  \label{figure:refactoring-editor}
\end{figure}

How the refactorings can be integrated will be shown on a concrete example: the Refactoring Editor shown in \figref{figure:refactoring-editor}. We show the detailed instructions for the \src{Rename} refactoring only, but others can be integrated analog. The following code is all performed in an action listener. First we have to instantiate the refactoring:

\begin{lstlisting}
val refactoring = new Rename with CompilerProvider with GlobalIndexes {
  val ast = treeFrom(editor.getText)
  val index = GlobalIndex(ast)
}
\end{lstlisting}

The compiler in this example is provided by the \src{CompilerProvider} trait, which also offers the \src{treeFrom} method to turn a string into a \src{Tree} instance. The Rename refactoring also needs an index of the whole program; we mix in the \src{GlobalIndexes} trait that allows us to construct an index (more on the index can be found in Section~\vref{section:analysis}).

Most of the refactorings need a selection to work. The \src{Selection} trait is implemented in two variations: \src{FileSelection} and \src{TreeSelection}. Depending on where the selection comes from, one or the other is easier to use. We create a \src{FileSelection} from the editor's selection:

\begin{lstlisting}
val selection: refactoring.Selection = {
  val file = refactoring.ast.pos.source.file
  val from = editor.getSelectionStart
  val to = editor.getSelectionEnd
  new refactoring.FileSelection(file, from, to)
}
\end{lstlisting}

Having a selection, we can now invoke the first refactoring step: the \src{prepare} method. Calling \src{prepare} returns \src{Either[PreparationError, PreparationResult]}, so we have to extract the result, or abort if an error occured (a typical error cause is an unsuitable selection).

\begin{lstlisting}
val preparationResult = refactoring.prepare(selection) match {
  case Left(refactoring.PreparationError(error)) => 
    showError(error)
    return
  case Right(r) => r
}
\end{lstlisting}

The preparation result's concrete type depends on the chosen refactoring. In the case of Rename, it simply contains the tree that we want to rename. Now to perform the refactoring, we need to pass the required parameters -- the new name. The \src{askName} function of our editor opens a dialog to enter a new name.

\needspace{6\baselineskip}
\begin{lstlisting}
val refactoringParameters = new refactoring.RefactoringParameters {
  val newName = {
    val oldName = preparationResult.selectedTree.symbol.nameString
    askNewName(oldName)
  }
}
\end{lstlisting}

Performing the refactoring is very similar to preparing it, except that we pass more parameters and get back a list of changes on success:

\begin{lstlisting}
val changes: List[Change] = 
  refactoring.perform(selection, preparationResult, refactoringParameters) match {
    case Left(refactoring.RefactoringError(error)) => 
      showError(error)
      return
    case Right(r) => r
  }
\end{lstlisting}

In our editor, we simply apply the changes to the file, using the \src{Change.applyChanges} method. In a real editor, the user should get a chance to see the proposed changes before they are applied.

\section{Scala IDE for Eclipse Integration}

The Eclipse integration is of course more complex than our previous example with the Refactoring Editor. Eclipse's Java Development Tools provides a rich set of refactorings; the core of this -- the Eclipse Language Toolkit \cite{LTK} -- can be used independently of the JDT and provides common functionality -- for example, wizards that guide the user through the refactoring process, edit and change objects that represent the refactoring's outcome, a viewer to visualize the patch. The LTK also takes care of applying the changes to the source code and undo management. 

\subsection{Integrating with Eclipse LTK}

We will now take a look at how the Refactoring library has been integrated into the Scala IDE for Eclipse. The diagram in \figref{figure:eclipse-integration} gives on overview over the main classes. 

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{eclipse-integration.pdf}
  \caption{An overview over the integration in the Scala IDE for Eclipse; the classes that are not in boxes are part of the Scala IDE integration. The classes with ellipsis stand for the other refactorings that are implemented in the same way.}
  \label{figure:eclipse-integration}
\end{figure}

\begin{description}
  \item[ActionAdapter] unifies and simplifies the integration into Eclipse's menu bar and context menus. It provides default implementations for unused methods.
  
  \item[ScalaIdeRefactoring] serves as a bridge between the LTK and a refactoring in the library; it connects the LTK's refactoring with the library's refactorings by creating the change objects for Eclipse (these are not the same as the \src{Change} objects in the library) and checks the initial and final conditions of a refactoring, i.e. it displays the errors that can be returned by \src{prepare} and \src{perform}.
  
  \item[ScalaRefactoringWizard] wraps the \src{ScalaIdeRefactoring} in a wizard and adds pages from the refactoring to the wizard.
  
  \item[RefactoringAction] is the abstract driver of a refactoring execution: it is the entry point when a refactoring is executed and manages the wizards.
  
  \item[RenameAction] finaly implements the \src{RefactoringAction} and contains all refactoring specific code. It instantiates the corresponding refactoring from the library and provides it to the generic \src{RefactoringAction}. The other refactorings are implemented analog by their respective actions.
  
  \item[RenameScalaIdeRefactoring] Adapts the Rename Refactoring from the library to the \src{ScalaIdeRefactoring} interface. An example of the \src{ExtractMethodScalaIdeRefactoring} will be shown later.
\end{description}

All these actions are hooked up to the Eclipse menus in the Scala IDE's \src{plugin.xml}.

\subsection{Interfacing with the Scala IDE}

As we have mentioned several times, the refactoring library needs to be given an instance of the compiler. In the Scala IDE integration, the compiler can be accessed through the \src{ScalaSourceFile}, which mixes in the \src{ScalaCompilationUnit} trait that offers the following method:

\begin{lstlisting}
trait ScalaCompilationUnit extends %\ldots%
  def withCompilerResult[T](op: ScalaPresentationCompiler.CompilerResultHolder => T): T
  %\ldots%
}
object ScalaPresentationCompiler {
  
  trait CompilerResultHolder {
    val compiler : ScalaPresentationCompiler
    val sourceFile : SourceFile
    val body : compiler.Tree
    val problems : List[IProblem]
  }
  %\ldots%
}
\end{lstlisting}

This gives us access to the underlying compiler and the parsed and type-checked tree. In the integration code, this can then be used as follows:

\begin{lstlisting}
file.withCompilerResult(crh =>  %\ldots%)
\end{lstlisting}

The \src{EditorHelpers} object contains additional methods that make some of the often used Eclipse functions more suitable for Scala -- working with \src{Option} instead of \src{null} and higher order utility functions similar to the \src{withCompilerResult} method above:

\begin{lstlisting}
object EditorHelpers {

  def activeWorkbenchWindow: Option[IWorkbenchWindow] = %\ldots%

  def activePage(w: IWorkbenchWindow): Option[IWorkbenchPage] = %\ldots%

  def activeEditor(p: IWorkbenchPage): Option[IEditorPart] = %\ldots%

  def textEditor(e: IEditorPart): Option[ScalaSourceFileEditor] = %\ldots%

  def withCurrentEditor[T](block: ScalaSourceFileEditor => Option[T]): Option[T] = %\ldots%

  def withCurrentScalaSourceFile[T](block: ScalaSourceFile => T): Option[T] = %\ldots%
}
\end{lstlisting}

\subsection{A Concrete Example}

To wrap up this chapter, let us take a look at a  concrete \src{ScalaIdeRefactoring} and \src{RefactoringAction} implementation. The \src{ExtractMethodAction} inherits from the \src{RefactoringAction} template method and has to implement the \src{createRefactoring} method which returns a \src{ScalaIdeRefactoring} instance:

\begin{lstlisting}
class ExtractMethodAction extends RefactoringAction {
  def createRefactoring(start: Int, end: Int, file: ScalaSourceFile) = 
    Some(new ExtractMethodScalaIdeRefactoring(start, end, file))
}
\end{lstlisting}

The \src{ExtractMethodScalaIdeRefactoring} class then adapts the library's Extract Method refactoring implementation. All the non-refactoring specific code, like calling \src{perform}, is done in \src{ScalaIdeRefactoring}.

\newpage
\begin{lstlisting}
class ExtractMethodScalaIdeRefactoring(start: Int, end: Int, file: ScalaSourceFile) 
    extends ScalaIdeRefactoring("Extract Method") {
  
  var name = ""
  
  val refactoring = file withCompilerResult { crh => 
    new ExtractMethod with GlobalIndexes with NameValidation {
      val global = crh.compiler
      val index = GlobalIndex(global.unitOfFile(crh.sourceFile.file).body)
    }
  }

  lazy val selection = createSelection(file, start, end)

  def initialCheck = file.withCompilerResult { crh =>
    refactoring.prepare(selection)
  }
  
  def refactoringParameters = new refactoring.RefactoringParameters {
    val methodName = name
  }
  
  override def getPages = 
    new NewNameWizardPage(
      s => name = s, 
      refactoring.isValidIdentifier, 
      defaultName = "extractedMethod") :: Nil 
}
\end{lstlisting}

The \src{NewNameWizardPage} is an SWT page that asks the user for a new name (see \figref{figure:extract-local-screenshot-1} for a screenshot). The closure passed as the first parameter is called whenever the name changes, so we can update our reference. The second parameter is a function of type $String \Rightarrow Boolean$ which is used to validate the entered name. Our name-updating closure is only called when the name passes the validation.

The actions for refactorings that use the inline mode -- Extract Local and Rename (Local) -- override some of the \src{ScalaIdeRefactoring}'s methods to bypass the wizard and set up the linked mode user interface directly.

\subsection{Adding New Refactorings}

Integrating a new refactoring with the Scala Eclipse plug-in can be done in three steps:

\begin{enumerate}
  \item Subclass \src{ScalaIdeRefactoring} and implement the necessary methods, analog to the existing IDE refactoring implementations. Organize Imports can serve as an example for a refactoring that does not need any configuration. If configuration is necessary, Extract Method or Rename can be the adapted.
  \item Create a \src{RefactoringAction} subclass that instantiates the previously created IDE refactoring.
  \item Add the new \src{RefactoringAction} to the plugin xml. The current implementations also show how shortcuts can be registered.
\end{enumerate}

With the existing refactoring implementations as a guideline, adding a new refactoring to the Scala IDE for Eclipse should easily be possible.

\chapter{Testing} \label{chapter:testing}

The necessity of automated testing in modern software projects bears no repetition. Especially with a project that is so intrinsically dependent on another component -- the Scala compiler -- and its internals, having a strong suite of integration tests is essential. 

The following chapter shows how the refactoring integration tests are implemented with the goal to provide a guide for creating new tests.

\section{Compiling Test Code}

When the refactoring implementations are used, the IDE or more generally the invoking tool provides access to the compiler. The refactoring themselves do not posses the ability to analyze the code. In the tests, we therefore also have to provide a compiler that parses and type-checks our test code.

Because instantiating and initializing the compiler is a rather expensive operation, one compiler instance is shared among all the tests. The \src{CompilerProvider} trait shown below gives us access to this instance and provides functionality to turn a string into a fully typed \src{Tree} instance and to add a file in the form of a string to the compiler:

\begin{lstlisting}
trait CompilerProvider {

  val global = CompilerInstance.compiler
    
  def treeFrom(src: String): global.Tree = %\ldots%
  
  def addToCompiler(name: String, src: String): AbstractFile = %\ldots%
}
\end{lstlisting}

Sharing a compiler instance is not without problems: because all the compilation units end up in the same compiler, this might result in conflicts. But this can easily be avoided by putting the individual test cases into their own package.

\section{Creating a Project Layout}

Now that we have a compiler, we need a way to represent Scala source files and combine them to a project-like structure. Thanks to Scala's support for raw strings, we can embed the Scala source code directly in our test cases and do not have to store them in external files or concatenate strings together. So in our test cases we can construct an AST from a string like this:

\begin{lstlisting}
val tree: global.Tree = treeFrom("""
  object Main {
    def main(args: Array[String]) {
    }
  }
""")
\end{lstlisting}

The \src{FileSet} class can be used to represent a Scala test project. It has an implicit conversion (see Appendix \vref{section:implicit-conversions}) method that adds the \src{becomes} method to \src{String} so it can be used as follows:

\begin{lstlisting}
val project = new FileSet {
  """
    Content of this source file.
  """ becomes
  """
    Expected test result for this file.
  """;

  "a second source file" becomes " %\ldots% "
}
\end{lstlisting}

The \src{FileSet} class also contains a method \src{applyRefactoring} that takes a function of type $FileSet \Rightarrow List[Change]$ which it uses to turn the specified source files into a list of changes. The changes are then applied to the sources and their result compared to the expected results using the standard JUnit asserts.

\section{Implementation}

Taking a look at a test for the \src{Organize Imports} refactoring, the result looks as follows:

\begin{lstlisting}
@Test
def sortImportsByName = new FileSet {
  """
    import scala.collection.mutable.ListBuffer
    import java.lang.Object

    object Main
  """ becomes
  """
    import java.lang.Object
    import scala.collection.mutable.ListBuffer

    object Main
  """
} applyRefactoring %\textbf{organize}%
\end{lstlisting}

The \src{organize} function simply instantiates the concrete refactoring and performs it, returning the list of changes the refactoring generated. Organize Imports is a very simple refactoring because it needs neither a selection from the user nor any other configuration. A test case for the Rename refactoring can be seen in the following listing:

\begin{lstlisting}
@Test
def renameSelfType = new FileSet {
  """
  trait /*(*/T1/*)*/

  trait T3 {
    self: T1 %$\Rightarrow$%

  }""" becomes
  """
  trait /*(*/Trait/*)*/

  trait T3 {
    self: Trait %$\Rightarrow$%

  }"""
} applyRefactoring %\textbf{renameTo}%("Trait")
\end{lstlisting}

The selection is indicated by the two comments \src{/*(*/} and \src{/*)*/}. The comments remain in the source code, this is why we also see them in the expected result. 

Now we also need a way to pass the new method's name. With the help of Scala's multiple argument lists and partial application of functions, the \src{renameTo} function can be implemented like this:

\begin{lstlisting}
def renameTo(name: String)(pro: FileSet): List[Change] = %\ldots%
\end{lstlisting}

Now the first argument -- the new name -- is applied during the test setup, and the resulting function is then passed to the \src{applyRefactoring} just like before.

\chapter{Outlook and Conclusion} \label{chapter:outlook}

\section{Accomplishments}

XXX needs some kind of conclusion, we have achieved our goal of having source generation that doesn't need user interaction.

other usages (Richard?)


\section{Acknowledgments}

I would like to thank ..

\section{Future Work}

what is left to do, how can the work be extended

\appendix

\chapter{User Guide} \label{chapter:user-guide}

This appendix describes the implemented refactorings from the user's perspective. We show how the refactorings can be invoked, what features and limitations they have.

The refactorings are all accessible from the Refactoring menu and with various shortcuts:

\begin{center}
  \includegraphics[width=0.6\linewidth]{refactoring-menu-screenshot.png}
\end{center}

\section{Rename}

The Rename refactoring can be used to rename all the names that occur in a Scala program. This includes for example: methods, classes, objects, local variables, method parameters, type parameters. To perform the refactoring, the name has to be selected -- placing the cursor on the name suffices -- and then the refactoring can be invoked. 

If the name to rename is only accessible in the source file -- for example,  a local variable -- or a method inside another method, then the refactoring is invoked in the inline mode, which links all occurences in the source file and changes them as you type:

\begin{center}
  \includegraphics[width=0.5\linewidth]{rename_screenshot_3.png}
\end{center}

If the name is accessible from outside the source file, the renaming is done in the wizard and the changes can be previewed:

\begin{center}
  \includegraphics[width=\linewidth]{rename_screenshot_2.png}
\end{center}

When the new name is entered via the wizard, it is checked if it is valid and not already in use.

\subsection{Limitations}

When renaming a top-level type in a file where the source file has the same name as the type, the file is currently not renamed. 

Scala 2.8 introduced named parameters, but because of how they are represented internally, they are not being renamed at the moment, leading to compile errors.

\section{Organize Imports}

Organize Imports cleans up the import statements in the current file. It does however not remove any unused imports nor imports that are needed for the program to compile. The refactoring does the following to the imports:

\begin{description}
  \item[Sorts] the statements alphabetically by their full name.
  \item[Collapses] multiple distinct imports from the same package into a single statement.
  \item[Simplifies] the imports: when a wilcard imports the whole package content, individual import from that package are removed, unless they contain renames.
\end{description}

The following screenshot shows the changes Organize Imports proposes:

\begin{center}
  \includegraphics[width=\linewidth]{organize_screenshot_1.png}
\end{center}

\subsection{Limitations}

The current implementation has some limitations compared to its Java counterpart. The refactoring does not do any dependency analysis, imports that are missing are not added, and unneeded imports are not being removed by Organize Imports. 

\section{Extract Local}

Extract Local allows you to introduce a new local variable from an expression: the value is initialized with the selected expression and the original  expression is replaced with a reference to the new value. 

The refactoring is also known as Introduce Explaining Variable, because it allows the programmer to simplify long expressions by splitting them into several smaller ones and making the code more readable. 

Selecting an expression like in the following screenshot:

\begin{center}
  \includegraphics[width=0.8\linewidth]{extract_local_screenshot_2.png}
\end{center}

and then executing the refactoring creates a new local variable and lets you change the name in Eclipse's linked mode:

\begin{center}
  \includegraphics[width=0.8\linewidth]{extract_local_screenshot_3.png}
\end{center}

Extracting new local values can also be useful for debugging to see the intermediate results of a computation.

\section{Extract Method}

The Extract Method refactoring lets you extract one or many expressions into a new private method. The refactoring takes care of passing all necessary parameters to the method and returns all values that are needed.

To invoke the refactoring, a selection inside of a method has to be made. The refactoring wizard will then ask for a new name and show a preview of the changes:

\begin{center}
  \includegraphics[width=\linewidth]{extract_method_screenshot_1.png}
\end{center}

Compared to Eclipse's Extract Method for Java, the Scala version currently lacks many features -- for example, one cannot reorder the parameters, nor rename them. Allowing the user to choose where the extracted method should be placed also has not been implemented yet, and the visibility of the extracted method is always set to private.

\chapter{Developer How-To} \label{chapter:developer-how-to}

This appendix provides an introduction for developers that are interested in developing new refactorings. We will create a new refactoring step-by-step and point to the relevant sections in the main documentation for details and background information. 

%Why should anybody want to write a refactoring? IDEs usually provide a variety of general refactorings and code generators, but maybe a framework or project specific automated refactoring that no IDE offers would be helpful. 

Before we start, we should clarify that when we write about \textit{refactoring}, this includes all program transformations that affect the source code, so a transformation that just creates new code -- e.g. adds a method to a class -- can be implemented as well.

\section{Introduction}

A refactoring is essentially a transformation of the program in its abstract syntax tree form. Because our Scala programs are stored in plain text files, the transformed syntax tree has to be converted back to text -- and this without losing all our pretty formatting. 

One of the design goals of the Scala Refactoring library was to separate these two concerns as good as possible, so that the implementor of a refactoring can concentrate on transforming trees and let the library handle all the code generation for him (for more information on how the code generation works, see Section~\vref{section:source-generation}). 

To make it easier for those who already know the Scala compiler's abstract syntax tree (AST), the refactorings are completely based on this AST instead of introducing a new program representation (the Scala AST is documented in Appendix~\vref{chapter:scala-ast}). 

\section{The Example}

In Scala, the compiler generates getters and setters for us; this is great for the common case where the value is just set or retrieved. If one needs to do more -- for example validate the new value, Scala allows to write explicit getters and setters. The following listing shows the original code:

\needspace{3\baselineskip}
\begin{lstlisting}
class Person(val name: String, var age: Int) {
  def debug = name +" is "+ age +" years old."
}
\end{lstlisting}

and the same with explicit getters and setters (remember that in Scala \src{person.age = 42} is the same as \src{person.age\_=(42)}):

\needspace{5\baselineskip}
\begin{lstlisting}
class Person(name: String, private var _age: Int) {
  def debug = name +" is "+ age +" years old."
  def age = _age
  def age_=(age: Int) = _age = age
}
\end{lstlisting}

Now let us automated this! In this example, we will concentrate on the refactoring implementation only; how the integration into the IDE or an other tool could look like is explained in Chapter~\vref{chapter:tool-integration}.

To keep our example as simple as possible, the refactoring will only take two parameters: a string that represents the source code and an integer for the current caret position -- that is, the selected value or variable for which the refactoring should create explicit getters and setters. The result of this operation is another string that representes the refactoring program. 

The refactoring will have to perform the following operations:

\begin{enumerate}
  \item Find out which value the user selected.
  \item Find the class that the selected value belongs to.
  \item Create a private field for the selected value.
  \item Create the getter and the setter. The setter is only needed when the selected value is mutable.
  \item Transform the AST to include the new methods and changed field.
  \item Turn the changed AST back into source code.
\end{enumerate}

\section{Implementing It}

Refactoring implementations subclass from \src{scala.tools.refactoring.Refactoring}, which has an abstract member \src{global: scala.tools.nsc.interactive.Global} -- an instance of the compiler that is typically provided by the IDE. Because we are not implementing this example in an IDE setting, we can mix in the \src{scala.tools.refactoring.util.CompilerProvider} trait which instantiates a compiler for us.

So far, our code looks as follows:

\begin{lstlisting}
class GenerateGettersAndSettersRefactoring(sourceCode: String, caretPosition: Int) 
    extends Refactoring with CompilerProvider {
  
  import global._
  
  def refactor(): String = { %\ldots% }
}
\end{lstlisting}

In the remainder of the example, we will complete the \src{refactor} method. The first thing we need to do is to turn the \src{sourceCode} string into an AST. The \src{treeFrom} method mixed in from \src{CompilerProvider} can do this:

\begin{lstlisting}
    val ast: Tree = treeFrom(sourceCode)
\end{lstlisting}

The \src{ast} value now holds a reference to the root element of the AST. Next we want a way to find out on which \src{val} (or \src{var}) the caret is positioned, and we need to know the corresponding template (the body of the class), where we later want to insert the getters and setters. From the source file and the caret position, we can create a \src{Selection} object which contains methods to find selected trees:
    
\begin{lstlisting}
    val selection = new FileSelection(ast.pos.source.file, caretPosition, caretPosition+1)
    
    val selectedValue = selection.findSelectedOfType[ValDef].getOrElse {
      return "No val/var selected."
    }
    
    val template = selection.findSelectedOfType[Template].getOrElse {
      return "No enclosing class found."
    }

    val createSetter = selectedValue.symbol.isMutable
\end{lstlisting}

Now that we know more about the selected value, we can start creating the new trees that we are going to insert into the AST. The new private field is created by prefixing the existing one with \src{\_}. We also need to adjust the modifiers of the field:

\begin{lstlisting}
    val privateName = "_"+ publicName
    
    val privateFieldMods = if(createSetter) {
      Modifiers(Flags.PARAMACCESSOR).
        withPosition (Flags.PRIVATE, NoPosition).
        withPosition (Tokens.VAR, NoPosition)
    } else {
      Modifiers(Flags.PARAMACCESSOR)
    }
      
    val privateField = selectedValue copy (mods = privateFieldMods, name = privateName)
\end{lstlisting}

The \src{withPosition} calls make sure that the field gets \src{private var} modifiers. Modifiers serve two purposes here: they describe the role of the tree -- \textsc{\src{paramaccessor}} -- and the modifiers that need to be present in the source code -- \textsc{\src{private}} and \textsc{\src{var}}.

The getter and setter trees are simple method definitions (see Appendix~\vref{chapter:scala-ast} for more information on the AST classes):

\begin{lstlisting}
    val getter = DefDef(
        mods = Modifiers(Flags.METHOD) withPosition (Flags.METHOD, NoPosition), 
        name = publicName, 
        tparams = Nil, 
        vparamss = List(Nil), 
        tpt = EmptyTree, 
        rhs = Block(
                Ident(privateName) :: Nil, EmptyTree))
    
    val setter = DefDef(
        mods = Modifiers(Flags.METHOD) withPosition (Flags.METHOD, NoPosition), 
        name = publicName +"_=",
        tparams = Nil,
        vparamss = List(List(ValDef(Modifiers(Flags.PARAM), publicName, 
                               TypeTree(selectedValue.tpt.tpe), EmptyTree))), 
        tpt = EmptyTree,
        rhs = Block(
                Assign(
                  Ident(privateName),
                  Ident(publicName)) :: Nil, EmptyTree))
\end{lstlisting}

The \src{vparamss} argument is a list of lists, because of Scala's multiple argument lists. Note that we use the selected value's type tree for the formal parameter's \src{ValDef}. In general, one does not have to specify any types in the modified trees except when they should be printed in the source code.

The \src{rhs} of the setter is simply an assignment with the private name on the left and the public name on the right. Both \src{rhs} are wrapped in a \src{Block} to make sure the source generator prints curly brackets around the method.

Now that we have all the trees, we need to insert them into our existing AST. Modifying ASTs is done with \textit{transformations} (see Section~\vref{section:transformation}). A transformation is basically a function that takes a tree and returns an \src{Option[Tree]}. This transformation is then applied to all trees in the AST. 
\newpage
The \src{transform} function creates a transformation from a partial function and is used as follows:

\begin{lstlisting}
    val insertGetterSettersTransformation = transform {
        
      // only apply the transformation to the selected template
      case tpl: Template if tpl == template => 
      
        // find the selected value in the class body and replace it with our privateField
        val classParameters = tpl.body.map { 
          case t: ValDef if t == selectedValue => privateField setPos t.pos
          case t => t 
        }
      
        // only create a setter when we have a `var`
        val body = if(createSetter)  
          getter :: setter :: classParameters
        else
          getter :: classParameters
        
        tpl.copy(body = body) setPos tpl.pos
    }
\end{lstlisting}

Note the \src{setPos} calls: Whenever a new tree should replace an existing one -- that is, be inserted at the same position and taking over the original tree's comments -- we give it the original tree's position.

We now have a generic transformation, but it has not been applied to our AST yet. There exist different strategies on how to do this, for our transformation we traverse the tree top-down (or pre-order) and try to apply \src{insertGetterSettersTransformation} to all subtrees. If the transformation can be applied, the modified tree replaces the original one; otherwise the original tree is retained.

\begin{lstlisting}
    val transformedAst = topdown(
                           matchingChildren(
                             insertGetterSettersTransformation)) apply ast
\end{lstlisting}
    
The AST can now be transformed into a list of change objects -- i.e a patch -- that can then be applied to the source code:

\begin{lstlisting}
    val changes = refactor(transformedAst.toList)
    
    Change.applyChanges(changes, sourceCode)
\end{lstlisting}

\section{The Result}

Applying the refactoring to both attributes of our original example:

\begin{lstlisting}
class Person(val name: String, var age: Int) {
  def debug = name +" is "+ age +" years old."
}
\end{lstlisting}

yields the following result:

\needspace{12\baselineskip}
\begin{lstlisting}
class Person(_name: String, private var _age: Int) {
  def age = {
    _age
  }
  def age_=(age: Int) = {
    _age = age
  }
  def name = {
    _name
  }
  def debug = name +" is "+ age +" years old."
}
\end{lstlisting}

This concludes our example of an automated refactoring implementation. All we had to do was to create some trees and write a transformation that applied our changes to the AST; turning the AST back into source code happened almost automatically.

The implementation of this refactoring can be found in the \src{implementations} package of the library. To see how other refactorings were implemented, continue reading Chapter~\vref{chapter:implemented-refactorings}. To learn more about the internals of the library, take a look at Chapter~\vref{chapter:refactoring-library}.

\include{9_appendix}

\include{91_scala_ast}

\clearpage
\bib

\end{document}


