/**
 *	(C)opyright 2006-2009 Hanns Holger Rutz. All rights reserved.
 *	Distributed under the GNU General Public License (GPL).
 *
 *	Class dependancies: TypeSafe, SynthDefCache
 *
 *	@author	Hanns Holger Rutz
 *	@version	0.19, 31-Aug-09
 *
 *	@todo	buffers must be stored per instance (of subclass) !!!
 */
NuagesU : Object {
	var <server, defWatcher;
	var volume = 1.0;
	
//	/**
//	 *	Returns the number of output channels
//	 *	generated by this object. This value
//	 *	may initially be zero and change depending
//	 *	on object state (e.g. setting sound file path
//	 *	for a TapeUnit).
//	 *
//	 *	@returns	(Integer) number of current output channels
//	 */
//	var <numChannels = 0;
	
	var audioInBusses, audioOutBusses, controlInBusses, controlOutBusses;
	var playing = false, target = nil;
	var <>verbose = false;
	var nw, updRemoveNode;
	var nodes;				// Set[ Node ]
	
	var <disposed	= false;
	
	var <>name;
	
	var attrs;				// sorted list
	var mapNameToAttr;			// Symbol: attr-name, to UnitAttr
	var mapNameToAttrValue;		// Symbol: attr-name, to some value

	*displayName {
		var name;
		name	= this.name.asString;
//		^name.copyRange( 6, name.size - 5 ).asSymbol;
		^name.copyToEnd( 7 ).asSymbol;
	}
	
	// ----------- instantiation -----------

	*new { arg server;
		^super.new.prInitNuagesU( server );
	}
	
	asString {
		^("a "++this.class.name++" (hash "++this.hash++")");
	}

//	tryChanged { arg ... args;
//		dependantsDictionary.at( this ).copy.do({ arg item;
//			try {
//				item.update( this, *args );
//			} { arg e;
//				e.reportError;
//			};
//		});
//	}
	
	prInitNuagesU { arg argServer;
		server			= argServer ?? Server.default;
		nw				= NodeWatcher.newFrom( server );
		defWatcher		= NuagesSynthDefWatcher.newFrom( server );
//		defCache			= SynthDefCache.newFrom( server );
//		name				= this.class.name.asString;
//		name				= name.copyRange( 6, name.size - 5 ).asSymbol;
		name				= this.class.displayName;
		mapNameToAttr		= IdentityDictionary.new;
		mapNameToAttrValue	= IdentityDictionary.new;

		audioInBusses		= nil ! this.numAudioInputs;
		audioOutBusses	= nil ! this.numAudioOutputs;

		controlInBusses	= nil ! this.numControlInputs;
		controlOutBusses	= nil ! this.numControlOutputs;
		
		updRemoveNode 	= UpdateListener({ arg upd, node;
			upd.remove;
			nodes.remove( node );
		}, \n_end );

//		CmdPeriod.add( this );
//		server.addDependant( this );
//		this.prReinitialize;
//("create : " ++ this.asString).postln;
	}

	// ----------- class methods -----------

	// ----------- public instance methods -----------

	autoPlay { ^true }

	numAudioInputs { ^this.subclassResponsibility( thisMethod )}
	numAudioOutputs { ^this.subclassResponsibility( thisMethod )}
	getAudioInputName { arg idx; ^this.subclassResponsibility( thisMethod )}
	getAudioOutputName { arg idx; ^this.subclassResponsibility( thisMethod )}
	numVisibleAudioInputs { ^this.numAudioInputs }
	numVisibleAudioOutputs { ^this.numAudioOutputs }
	isAudioInputReadOnly { arg idx = 0; ^true }

	numControlInputs { ^this.subclassResponsibility( thisMethod )}
	numControlOutputs { ^this.subclassResponsibility( thisMethod )}
	getControlInputName { arg idx; ^this.subclassResponsibility( thisMethod )}
	getControlOutputName { arg idx; ^this.subclassResponsibility( thisMethod )}
	numVisibleControlInputs { ^this.numControlInputs }
	numVisibleControlOutputs { ^this.numControlOutputs }

	attributes { ^attrs } // hmmm... should be a copy (immutable), but this gets called too often...
	getAttribute { arg name; ^mapNameToAttr[ name ]}
	
	dispose {
		var bndl;
		
		bndl = OSCBundle.new;
		this.disposeToBundle( bndl );
		bndl.send( server );
	}
	
	disposeToBundle { arg bndl;
		if( disposed, {
			TypeSafe.methodError( thisMethod, "Object already disposed" );
			^this;
		});

		this.stopToBundle( bndl );
//		this.freeBuffers;
//		CmdPeriod.remove( this );
//		server.removeDependant( this );
		disposed = true;
		this.tryChanged( \unitDisposed );
	}
	
//	freeBuffers {
//		this.prFreeNodeBuffers;
//		this.prFreeGlobalBuffers;
//	}
	
	play {
		var bndl;

		bndl = OSCBundle.new;
		this.playToBundle( bndl );
		bndl.send( server );
	}

	isPlaying {
		^playing;
	}

	group_ { arg group;
		var bndl;
		
		bndl = OSCBundle.new;
		this.setGroupToBundle( bndl, group );
		bndl.send( server );
	}
	
	setGroupToBundle { arg bndl, group;

		TypeSafe.checkArgClasses( thisMethod, [ bndl, group ], [ OSCBundle, Group ], [ false, false ]);
		
		target = group;
		nodes.do({ arg node;
			bndl.add( node.moveToHeadMsg( group ));
		});
	}
	
	group {
		^target;
	}

	setAudioOutputBus { arg bus, idx = 0;
		var bndl;
		
//		[ "idx", idx ].postln;
		
		bndl = OSCBundle.new;
		this.setAudioOutputBusToBundle( bndl, bus, idx );
		bndl.send( server );
	}
	
	setAudioOutputBusToBundle { arg bndl, bus, idx = 0;
		var name, oldNumChans;
		
		TypeSafe.checkArgClasses( thisMethod, [ bndl, bus, idx ], [ OSCBundle, Bus, Integer ], [ false, false, false ]);
		
		oldNumChans = this.numOutChannels( idx );
		audioOutBusses[ idx ] = bus;
		if( oldNumChans == bus.numChannels, {
			if( nodes.size > 0, {
				name = if( idx == 0, \out, { "out" ++ (idx+1) });
				nodes.do({ arg node;
					bndl.add( node.setMsg( name, bus.index ));
				});
			});
		}, {
			if( this.isPlaying, {
				TypeSafe.methodWarn( thisMethod, "Changing # of Channels while Playing" );
				this.stopToBundle( bndl );
				this.tryChanged( \numOutChannels, idx ); // XXX might need to dispatch for each input / output ??
			});
		});
	}
	
	getAudioOutputBus { arg idx = 0;
		^audioOutBusses[ idx ];
	}
	
	setAudioInputBus { arg bus, idx = 0;
		var bndl;
		
//		[ "idx", idx ].postln;
		
		bndl = OSCBundle.new;
		this.setAudioInputBusToBundle( bndl, bus, idx );
		bndl.send( server );
	}

	setAudioInputBusToBundle { arg bndl, bus, idx = 0;
		var name, oldNumChans;
		
		TypeSafe.checkArgClasses( thisMethod, [ bndl, bus, idx ], [ OSCBundle, Bus, Integer ], [ false, false, false ]);

//"------ NuagesU.setInputBusToBundle : 1".postln;
		
		oldNumChans = this.numInChannels( idx );
//"------ NuagesU.setInputBusToBundle : 2".postln;
		audioInBusses[ idx ] = bus;
//"------ NuagesU.setInputBusToBundle : 3".postln;
		if( oldNumChans == bus.numChannels, {
			if( nodes.size > 0, {
				name = if( idx == 0, \in, { "in" ++ (idx+1) });
				nodes.do({ arg node;
					bndl.add( node.setMsg( name, bus.index ));
				});
	//			server.listSendBundle( nil, bndl );
			});
		}, {
			if( this.isPlaying, {
				TypeSafe.methodWarn( thisMethod, "Changing # of Channels while Playing" );
				this.stopToBundle( bndl );
				this.tryChanged( \numInChannels, idx ); // XXX might need to dispatch for each input / output ??
			});
		});
	}
	
	getAudioInputBus { arg idx = 0;
		^audioInBusses[ idx ];
	}
	
	setControlOutputBus { arg bus, idx = 0;
		var bndl;
		
		bndl = OSCBundle.new;
		this.setControlOutputBusToBundle( bndl, bus, idx );
		bndl.send( server );
	}
	
	setControlOutputBusToBundle { arg bndl, bus, idx = 0;
		var name;
		
		TypeSafe.checkArgClasses( thisMethod, [ bndl, bus, idx ], [ OSCBundle, Bus, Integer ], [ false, false, false ]);
		
		controlOutBusses[ idx ] = bus;
		if( nodes.size > 0, {
			name = if( idx == 0, \kout, { "kout" ++ (idx+1) });
			nodes.do({ arg node;
				bndl.add( node.setMsg( name, bus.index ));
			});
		});
	}
	
	getControlOutputBus { arg idx = 0;
		^controlOutBusses[ idx ];
	}
	
	setControlInputBus { arg bus, idx = 0;
		var bndl;
				
		bndl = OSCBundle.new;
		this.setControlInputBusToBundle( bndl, bus, idx );
		bndl.send( server );
	}

	setControlInputBusToBundle { arg bndl, bus, idx = 0;
		var name;
		
		TypeSafe.checkArgClasses( thisMethod, [ bndl, bus, idx ], [ OSCBundle, Bus, Integer ], [ false, false, false ]);
		
		controlInBusses[ idx ] = bus;
		if( nodes.size > 0, {
			name = if( idx == 0, \kin, { "kin" ++ (idx+1) });
			nodes.do({ arg node;
				bndl.add( node.setMsg( name, bus.index ));
			});
		});
	}
	
	getControlInputBus { arg idx = 0;
		^controlInBusses[ idx ];
	}

	numInChannels { arg idx = 0;
		if( audioInBusses[ idx ].notNil, { ^audioInBusses[ idx ].numChannels });
		^this.protPreferredNumInChannels( idx );
	}
	
	numOutChannels { arg idx = 0;
		if( audioOutBusses[ idx ].notNil, { ^audioOutBusses[ idx ].numChannels });
		^this.protPreferredNumOutChannels( idx );
	}
	
	setVolume { arg vol;
		var bndl;
		
		bndl = OSCBundle.new;
		this.setVolumeToBundle( bndl, vol );
		bndl.send( server );
	}
	
	setVolumeToBundle { arg bndl, vol;
		volume = vol;
//		[ "setVolume...", vol ].postln;
		nodes.do({ arg node;
//			[ "...", node ].postln;
			bndl.add( node.setMsg( \volume, vol ));
		});
	}

	addControlMapToBundle { arg bndl, attr, bus;
		nodes.do({ arg node;
// ! SOME SUCKER CHANGED THE API ! DON'T USE BUS INDICES ANY MORE !
//			bndl.add( node.mapMsg( attr.name, bus.index ));
			bndl.add([ "/n_map", node.nodeID, attr.name, bus.index ]);
		});
	}
	
	removeControlMapToBundle { arg bndl, attr;
		nodes.do({ arg node;
// ! SOME SUCKER CHANGED THE API ! DON'T USE BUS INDICES ANY MORE !
//			bndl.add( node.mapMsg( attr.name, -1 ));
			bndl.add([ "/n_map", node.nodeID, attr.name, -1 ]);
		});
	}
	
	getAttrValue { arg attr;
//		val getter;
//		getter = "get" ++ attr.name;
//		getter[ 3 ] = getter[ 3 ].toUpper;
//		getter = getter.asSymbol;
//		if( this.respondsTo( getter, {
//			^this.perform( getter );
//		}, {
			^(mapNameToAttrValue[ attr.name ] ?? {Êattr.spec.default });
//		});
	}

	setAttrValueToBundle { arg bndl, attr, value;
		var attrName = attr.name;
//		val setter;
//		setter = "set" ++ attrName ++ "ToBundle";
//		setter[ 3 ] = setter[ 3 ].toUpper;
//		setter = setter.asSymbol;
//		if( this.respondsTo( setter, {
//			setter.perform( bndl, value );
//		}, {
			mapNameToAttrValue[ attrName ] = value;
			nodes.do({ arg node;
				bndl.add( node.setMsg( attrName, value ));
			});
			this.tryChanged( \attrUpdate, attrName );
//		});
	}

	duplicate {
		var dup;
		
		if( disposed, {
			TypeSafe.methodError( thisMethod, "Trying to revive a disposed object" );
			^nil;
		});
		
		dup = this.class.new( server );
		dup.group = this.group;
		this.numAudioInputs.do({ arg idx; dup.setAudioInputBus( this.getAudioInputBus( idx ), idx )});
		this.numAudioOutputs.do({ arg idx; dup.setAudioOutputBus( this.getAudioOutputBus( idx ), idx )});
		this.numControlInputs.do({ arg idx; dup.setControlInputBus( this.getControlInputBus( idx ), idx )});
		this.numControlOutputs.do({ arg idx; dup.setControlOutputBus( this.getControlOutputBus( idx ), idx )});
		dup.setVolume( this.getVolume );
		dup.protSetAttrValues( mapNameToAttrValue );
		this.protDuplicate( dup );
		^dup;
	}
	
	getVolume {
		^volume;
	}

	stop { arg rls;
		var bndl;
		
		bndl = OSCBundle.new;
		this.stopToBundle( bndl, rls );
		bndl.send( server );
	}

	stopToBundle { arg bndl, rls;
		nodes.do({ arg node;
			if( rls.notNil, {
				bndl.add( node.releaseMsg( rls ));
			}, {
				bndl.add( node.freeMsg );
			});
		});
		nodes = nil;
		updRemoveNode.removeFromAll;
	}

	debugTrace {
		nodes.do({ arg node;
			node.trace;
		});
	}
	
	hasPreferredNumInChannels { ^false }
	shouldConnectOutputFirst { ^false }
		
	// ----------- protected instance methods -----------

	protSetAttrValues { arg map;
		mapNameToAttrValue = map.copy; // deep?
	}

	protSetAttrsToBundle { arg bndl;
		var args;
		if( this.respondsTo( \protSetAttrToBundle ), {
			nodes.do({ arg node;
				this.protSetAttrToBundle( bndl, node ); // XXX old fashion
			});
		}, {
			mapNameToAttrValue.keysValuesDo({ arg name, value; args = args.addAll([ name, value ])});
			nodes.do({ arg node;
				bndl.add( node.setMsg( *args ));
			});
		});
	}
	
	protMakeAttr { arg name, spec, type, getter, setter, updates, shouldFade = false, canMap = true;
		var attr = UnitAttr.make( name, spec, type, getter, setter, updates, shouldFade, canMap );
		attrs = [ attr ] ++ attrs;
		mapNameToAttr.put( attr.name, attr );
		^attr;
	}
	
	protPrependAttr { arg ... attrList;
		attrs = attrList ++ attrs;
		attrList.do({ arg attr; mapNameToAttr.put( attr.name, attr )});
	}
	
	protReplaceAttr { arg attr;
		var idx;
		idx = attrs.detectIndex({ arg a; a.name === attr.name });
		attrs[ idx ] = attr;
		mapNameToAttr.put( attr.name, attr );
	}

	protPreferredNumInChannels { arg idx; ^this.subclassResponsibility( thisMethod )}
	protPreferredNumOutChannels { arg idx; ^this.subclassResponsibility( thisMethod )}
	
	protCreateDefName { arg numInChannels, numChannels;
		var temp;
		if( numInChannels.isArray, {
			temp = numInChannels.copyToEnd( 1 );
			numInChannels = numInChannels[ 0 ].asString;
			temp.do({ arg i; numInChannels = numInChannels ++ "_" ++ i.asString });
		});
		if( numChannels.isArray, {
			temp = numChannels.copyToEnd( 1 );
			numChannels = numChannels[ 0 ].asString;
			temp.do({ arg i; numChannels = numChannels ++ "_" ++ i.asString });
		});
		^"nuages-%%x%".format( this.name, numInChannels ? 0, numChannels ? 0 ).asSymbol;
	}
	
	protNewSynthToBundle { arg bndl, synth, defGenFunc;
		var defName;
		this.protAddNode( synth );
		defName = synth.defName.asSymbol;
		if( defWatcher.isOnline( defName ).not, {
			defWatcher.sendToBundle( bndl, defGenFunc.value( defName ), synth );
		});
	}
	
	protAddNode { arg node;
		nodes = nodes.add( node );
		nw.register( node );
		updRemoveNode.addTo( node );
	}

	protRemoveNode { arg node;
		nodes.remove( node );
//		nw.unregister( node );
		updRemoveNode.removeFrom( node );
	}
			
	protSetPlaying { arg state;
		playing = state;
		this.tryChanged( \unitPlaying, state );
	}
	
	protMakeBundle { arg func;
		var bndl = OSCBundle.new;
		func.value( bndl );
		bndl.send( server );
	}

	protDuplicate { arg dup; }

	/**
	 *	@param	shrink	if not nil, the number of channels will be
	 *					limited to be at most this amount of channels
	 *	@param	extend	if not nil, the number of channels will be
	 *					extended _or shrunk_ to this amount of channels
	 */
	protCreateIn { arg busIdx, numChannels, shrink, extend;
		var inp, pan, ch2, w;
		inp = In.ar( busIdx, numChannels ).asArray;
		if( shrink.notNil and: { shrink < numChannels }, {
			pan = 0.0.dup( shrink );
			inp.do({ arg sig, ch;
				ch	= ch.linlin( 0, inp.size - 1, 0, shrink - 1 );
				w	= ch % 1.0;
				if( w == 0, {
					ch = ch.asInteger;
					pan[ ch ] = pan[ ch ] + sig;
				}, {
					ch2	= ch.ceil.asInteger;
					ch	= ch.floor.asInteger;
					pan[ ch ]  = pan[ ch ]  + (sig * (1.0 - w).sqrt);
					pan[ ch2 ] = pan[ ch2 ] + (sig * w.sqrt);
				});
			});
		});
		if( extend.notNil /* and: { extend > numChannels } */, {
			pan = 0.0.dup( extend );
			inp.do({ arg sig, ch;
				ch	= ch.linlin( 0, inp.size - 1, 0, extend - 1 );
				w	= ch % 1.0;
				if( w == 0, {
					ch = ch.asInteger;
					pan[ ch ] = pan[ ch ] + sig;
				}, {
					ch2	= ch.ceil.asInteger;
					ch	= ch.floor.asInteger;
					pan[ ch ]  = pan[ ch ]  + (sig * (1.0 - w).sqrt);
					pan[ ch2 ] = pan[ ch2 ] + (sig * w.sqrt);
				});
			});
		});
		
		// XXX there could be an option to re-pan input material
		// for now let's just reduce or extend it
//		if( shrink.notNil, { numChannels = min( numChannels, shrink )});
//		if( extend.notNil, { numChannels = max( numChannels, extend )});
//		^In.ar( busIdx, numChannels ).asArray;
		^(pan ? inp);
	}

	// ----------- private instance methods -----------

	// ----------- quasi-interface methods -----------
	
	// ----------- abstract methods -----------
 
	playToBundle {
		^this.subclassResponsibility( thisMethod );
	}
}